#------------------------------------------------------
###### Discrete-continuous dual families codes #######
#------------------------------------------------------
# Poisson distribution
pcpois <- function(q, lambda, lower.tail = TRUE){
  if(!is.numeric(q) | !is.numeric(lambda)) stop("inputs x and lambda must be numeric")
  if(lambda <= 0) stop("lambda must be positive")
  suppressWarnings(df <- pgamma(lambda, shape = q, lower.tail = !lower.tail))
  df[which(is.na(df) == TRUE)] = 0
  return(df)
}
# Poisson discrete
disP <- function(k, lambda){
  return(pcpois(k, lambda = lambda) - pcpois(k-1, lambda = lambda))
}
# Inverse Poisson discrete
disIP <- function(k, lambda){
  #if(k == 1){
#  return(1 - pcpois(1/k, lambda = lambda))
#  }
#  else{
    return(pcpois(1/(k - 1), lambda = lambda) - pcpois(1/k, lambda = lambda))
#  }
}

# 
disP <- function(k, lambda){
  return(pcpois(k+1, lambda = lambda) - pcpois(k, lambda = lambda))
}

disPcum <- function(x, lambda){
  ar <- array(NA, dim = length(x))
  for(i in x){
  ar[match(i, x)] <- sum(disP(1:i, lambda = lambda))
  }
  return(ar)
 # return(sum(disP(1:x, lambda = lambda)))
}

disIPcum <- function(x, lambda){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- sum(disIP(1:i, lambda = lambda))
  }
  return(ar)
  # return(sum(disP(1:x, lambda = lambda)))
}

plot(seq(1, 10), disP(1:10, 2), type = "h", col = "red")
points(seq(1, 10), disP(1:10, 2), type = "o", col = "red")
points(seq(1, 10), disIP(1:10, 2), type = "o", col = "blue")

plot(seq(1, 10), disP(1:10, 2), pch = 19, col = "red", ylim = c(0, max(disP(1:10, 2), disIP(1:10, 2))), xlab = "n", ylab = "P(n)")
points(seq(1, 10), disP(1:10, 2), col = "black", type = "h", lty = 3)
points(seq(1, 10), disIP(1:10, 2), col = "blue")
points(seq(1, 10), disIP(1:10, 2), col = "black", type = "h", lty = 3)
axis(1, at = seq(0:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(5, 0.85, pch = c(19, 1), col = c("red", "blue"),
       legend = c(expression(paste("Poisson (", lambda, " = ", 2, ")")), expression(paste("Inverse Poisson (", lambda, " = ",2, ")"))), bty ="n", cex = 1.2)


plot(seq(1, 15), disPcum(1:15, 2), type = "s", col = "red", xlab = "n", ylab = "F(n)")
points(seq(1, 15), disPcum(1:15, 2), type = "s", col = "red")
points(seq(1, 15), disIPcum(1:15, 2), type = "s", col = "blue")
axis(1, at = seq(0:15))
abline(v = seq(0, 15), col = "grey", lty = 3)
abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(7, 0.6, col = c("red", "blue"), legend = c("Poisson", "Inverse Poisson"), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.5)

par(mfrow = c(1, 2))
grid(ny = NA, col = "black", lty = 3)

points(seq(1, 10), disP(1:10, 2), type = "o", col = "red")
axis(1, at = seq(0:10))
grid()
points(seq(1, 10), disIP(1:10, 2), type = "o", col = "blue")

# Quick check of distribution for random mean
yy <- function(p, sims ){
  rr <- rgeom(n = sims, prob = p) + 1
  jj <- array(NA, dim = sims)

  for(i in rr){
  pos <- match(i, rr)
  jj[pos] <- (sum(runif(n = i, min = -1, max = 1))/i)/( (1/3)/sqrt(i) )
  }
  hist(jj, freq = FALSE, ylim = c(0 , dnorm(0)));points(seq(-3, 3, 0.01), dnorm(seq(-3, 3, 0.01)), type = "l" )
}

hist(rnorm(100))
points(seq(-2, 2, 0.01),seq(-2, 2, 0.01), type = "l" )

# Geometric discrete
disG <- function(k, p){
  lambda = -log(1 - p)
  return(pexp(k+1, rate = lambda) - pexp(k, rate = lambda))
}

# Inverse Geometric discrete
disIG <- function(k, p){
  lambda = -log(1 - p)
  jj <- array(NA, dim = length(k))
  for(i in k){
  pos <- match(i, k)
  jj[pos] <- exp(-(1*lambda)/(i + 1)) - exp(-(1*lambda)/i)
  }
  return(jj)
}

disGcum <- function(x, p){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- sum(disG(0:i, p = p))
  }
  return(ar)
}

disIGcum <- function(x, p){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- sum(disIG(0:i, p = p))
  }
  return(ar)
}

plot(seq(1, 10), disG(1:10, 1/3), type = "h", col = "red")
points(seq(1, 10), disG(1:10, 1/3), type = "o", col = "red")
points(seq(1, 10), disIG(1:10, 1/3), type = "o", col = "blue")

plot(seq(0, 10), disG(0:10, p=1/3), pch = 19, col = "red", ylim = c(0, max(disG(0:10, 1/3), disIG(0:10, 1/3))), xlab = "n", ylab = "P(n)")
points(seq(0, 10), disG(0:10, 1/3), col = "black", type = "h", lty = 3)
points(seq(0, 10), disIG(0:10, 1/3), col = "blue", pch = 19)
points(seq(0, 10), disIG(0:10, 1/3), col = "black", type = "h", lty = 3)
axis(1, at = seq(0:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(3, 0.5, pch = c(19, 19), col = c("red", "blue"),
       legend = c(expression(paste("Geometric (", p, " = ", 1/3, ")")), expression(paste("Inverse Geometric (", p, " = ",1/3, ")"))), bty ="n", cex = 1.2)

plot(seq(0, 15), disGcum(0:15, 1/3), type = "s", col = "red", xlab = "n", ylab = "F(n)")
points(seq(0, 15), disGcum(0:15, 1/3), type = "s", col = "red")
points(seq(0, 15), disIGcum(0:15, 1/3), type = "s", col = "blue")
axis(1, at = seq(0:15))
abline(v = seq(0, 15), col = "grey", lty = 3)
abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(4, 0.5, col = c("red", "blue"), legend = c("Geometric", "Inverse Geometric"), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.5)

# Geometric discrete
disG <- function(k){
  ar <- array(NA, dim = length(k))
  for(i in k){
    ar[match(i, k)] <- (exp(-1))^(i - 1)*(1 - exp(-1))
  }
  return(ar)}

# Inverse Geometric discrete
disIG <- function(k){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
    jj[pos] <- exp(-1/i) - exp(-1/(i - 1))
  }
  return(jj)}

disGcum <- function(x){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- sum(disG(1:i))
  }
  return(ar)}

disIGcum <- function(x){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- sum(disIG(1:i))
  }
  return(ar)}

#plot(seq(1, 10), disG(1:10), type = "h", col = "red")
#points(seq(1, 10), disG(1:10), type = "o", col = "red")
#points(seq(1, 10), disIG(1:10), type = "o", col = "blue")

plot(seq(1, 10), disG(1:10), pch = 19, col = "red", ylim = c(0, max(disG(1:10), disIG(1:10))), xlab = "n", ylab = "P(n)")
points(seq(1, 10), disG(1:10), col = "black", type = "h", lty = 3)
points(seq(1, 10), disIG(1:10), col = "blue", pch = 19)
points(seq(1, 10), disIG(1:10), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(5, 0.5, pch = c(19, 19), col = c("red", "blue"),
       legend = c("Geometric", "Inverse Geometric"), bty ="n", cex = 1.2)

plot(seq(1, 10), disGcum(1:10), ylim = c(0, max(disGcum(1:10), disIGcum(1:10))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(1, 10), disIGcum(1:10), type = "s", col = "blue")
axis(1, at = seq(1:10))
abline(v = seq(0, 10), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(4, 0.5, col = c("red", "blue"), legend = c("Geometric", "Inverse Geometric"), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.5)

library(expint)
####### discrete gamma and inverse gamma
disGam <- function(k, beta, alpha){
  ar <- array(NA, dim = length(k))
  for(i in k){
#   ar[match(i, k)] <- pgamma(beta*(i-i), shape = alpha, lower.tail = F) - pgamma(beta*i, shape = alpha, lower.tail = F)
    ar[match(i, k)] <- pgamma(i, shape = alpha, rate = beta) - pgamma(i-1, shape = alpha, rate = beta)
  }
  return(ar)}

# Inverse Geometric discrete
disIGam <- function(k, beta, alpha){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
    jj[pos] <- gammainc(alpha, beta/i)/gamma(alpha) - (gammainc(alpha, beta/(i - 1))/gamma(alpha))
  }
  return(jj)}

disGamcum <- function(x, beta, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- suppressWarnings(sum(disGam(k = 1:i, beta = beta, alpha = alpha)))
  }
  return(ar)}

disIGamcum <- function(x, beta, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disIGam(1:i, beta = beta, alpha = alpha)))
  }
  return(ar)}

#plot(seq(1, 10), disG(1:10), type = "h", col = "red")
#points(seq(1, 10), disG(1:10), type = "o", col = "red")
#points(seq(1, 10), disIG(1:10), type = "o", col = "blue")

plot(seq(1, 10), disGam(1:10, alpha = 2, beta = 1), pch = 19, col = "red", ylim = c(0, max(disGam(1:10, alpha = 2, beta = 1), disIGam(1:10, alpha = 2, beta = 1))), xlab = "n", ylab = "P(n)")
points(seq(1, 10), disGam(1:10, alpha = 2, beta = 1), col = "black", type = "h", lty = 3)
points(seq(1, 10), disIGam(1:10, alpha = 2, beta = 1), col = "blue", pch = 19)
points(seq(1, 10), disIGam(1:10, alpha = 2, beta = 1), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(3, 0.6, pch = c(19, 19), col = c("red", "blue"),
       legend = c(expression(paste("Discrete Gamma(", alpha, " = 2, ",beta," = 1)")), expression(paste("Inverse discrete Gamma(", alpha, " = 2, ",beta," = 1)" ))), bty = "n", cex = 1.2)
#       legend = c("Geometric", "Inverse Geometric"), bty ="n", cex = 1.2)

plot(seq(1, 15), disGamcum(1:15, alpha = 2, beta = 1), ylim = c(0, max(disGamcum(1:15, alpha = 2, beta = 1), disIGamcum(1:15, alpha = 2, beta = 1))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(1, 15), disIGamcum(1:15, alpha = 2, beta = 1), type = "s", col = "blue")
axis(1, at = seq(1:15))
abline(v = seq(0, 10), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(5, 0.5, col = c("red", "blue"), legend = c(expression(paste("Discrete Gamma(", alpha, " = 2, ",beta," = 1)")), expression(paste("Inverse discrete Gamma(", alpha, " = 2, ",beta," = 1)" ))), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.3)

# Weibull and inverse Weibull
disWei <- function(k, alpha){
  ar <- array(NA, dim = length(k))
  for(i in k){
    #   ar[match(i, k)] <- pgamma(beta*(i-i), shape = alpha, lower.tail = F) - pgamma(beta*i, shape = alpha, lower.tail = F)
    ar[match(i, k)] <- exp(-(i - 1)^alpha) - exp(-i^alpha)
  }
  return(ar)}

# Inverse Geometric discrete
disIWei <- function(k, alpha){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
    jj[pos] <- exp(-1/(i^alpha)) - exp(-1/(i - 1)^alpha)
  }
  return(jj)}

disWeicum <- function(x, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- suppressWarnings(sum(disWei(k = 1:i, alpha = alpha)))
  }
  return(ar)}

disIWeicum <- function(x, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disIWei(1:i, alpha = alpha)))
  }
  return(ar)}

#plot(seq(1, 10), disG(1:10), type = "h", col = "red")
#points(seq(1, 10), disG(1:10), type = "o", col = "red")
#points(seq(1, 10), disIG(1:10), type = "o", col = "blue")

plot(seq(1, 10), disWei(1:10, alpha = 0.5), pch = 19, col = "red", ylim = c(0, max(disWei(1:10, alpha = 0.5), disIWei(1:10, alpha = 0.5))), xlab = "n", ylab = "P(n)")
points(seq(1, 10), disWei(1:10, alpha = 0.5), col = "black", type = "h", lty = 3)
points(seq(1, 10), disIWei(1:10, alpha = 0.5), col = "blue", pch = 19)
points(seq(1, 10), disIWei(1:10, alpha = 0.5), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(4, 0.4, pch = c(19, 19), col = c("red", "blue"),
       legend = c(expression(paste("Discrete Weibull(", alpha, " = 0.5)")), expression(paste("Inverse discrete Weibull(", alpha, " = 0.5)" ))), bty = "n", cex = 1.2)
#       legend = c("Geometric", "Inverse Geometric"), bty ="n", cex = 1.2)

plot(seq(1, 15), disWeicum(1:15, alpha = 0.5), ylim = c(0, max(disWeicum(1:15, alpha = 0.5), disIWeicum(1:15, alpha = 0.5))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(1, 15), disIWeicum(1:15, alpha = 0.5), type = "s", col = "blue")
axis(1, at = seq(1:15))
abline(v = seq(0, 10), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(5, 0.5, col = c("red", "blue"), legend = c(expression(paste("Discrete Weibull(", alpha, " = 0.5)")), expression(paste("Inverse discrete Weibull(", alpha, " = 0.5)"))), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.3)

## Half-logistic
disHL <- function(k){
  ar <- array(NA, dim = length(k))
  for(i in k){
    ar[match(i, k)] <- ((1 - exp(-i))/(1 + exp(-i))) - ((1 - exp(-(i - 1)))/(1 + exp(-(i - 1))))
  }
  return(ar)}

disIHL <- function(k){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
    jj[pos] <-  2*( ( exp(-1/i)/(1 + exp(-1/i)) ) - ( exp(-1/(i - 1))/(1 + exp(-1/(i - 1)))))
  }
  return(jj)}

disHLcum <- function(x, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- suppressWarnings(sum(disHL(k = 1:i)))
  }
  return(ar)}

disIHLcum <- function(x, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disIHL(1:i)))
  }
  return(ar)}

#plot(seq(1, 10), disG(1:10), type = "h", col = "red")
#points(seq(1, 10), disG(1:10), type = "o", col = "red")
#points(seq(1, 10), disIG(1:10), type = "o", col = "blue")

plot(seq(1, 10), disHL(1:10), pch = 19, col = "red", ylim = c(0, max(disHL(1:10), disIHL(1:10))), xlab = "n", ylab = "P(n)")
points(seq(1, 10), disHL(1:10), col = "black", type = "h", lty = 3)
points(seq(1, 10), disIHL(1:10), col = "blue", pch = 19)
points(seq(1, 10), disIHL(1:10), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(4, 0.4, pch = c(19, 19), col = c("red", "blue"),
       legend = c("Discrete Half-Logistic", "Discrete inverse Half-Logistic"), bty = "n", cex = 1.2)
#       legend = c("Geometric", "Inverse Geometric"), bty ="n", cex = 1.2)

plot(seq(1, 15), disHLcum(1:15), ylim = c(0, max(disHLcum(1:15), disIHLcum(1:15))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(1, 15), disIHLcum(1:15), type = "s", col = "blue")
axis(1, at = seq(1:15))
abline(v = seq(0, 10), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(5, 0.4, col = c("red", "blue"), legend = c("Discrete Half-logistic", "Discrete inverse Half-logistic"), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.3)

# Discrete Pareto
disPare <- function(k, alpha){
  ar <- array(NA, dim = length(k))
  for(i in k){
    ar[match(i, k)] <- ( 1/(1 + alpha*(i -1)))^(1/alpha) - ( 1/(1 + alpha*i))^(1/alpha)
  }
  return(ar)}

disIPare <- function(k, alpha){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
    jj[pos] <-  (1/(1 + (alpha/i)))^(1/alpha) - (1/(1 + alpha/(i - 1)))^(1/alpha)
  }
  return(jj)}

disParecum <- function(x, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- suppressWarnings(sum(disPare(k = 1:i, alpha = alpha)))
  }
  return(ar)}

disIParecum <- function(x, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disIPare(1:i, alpha = alpha)))
  }
  return(ar)}

#plot(seq(1, 10), disG(1:10), type = "h", col = "red")
#points(seq(1, 10), disG(1:10), type = "o", col = "red")
#points(seq(1, 10), disIG(1:10), type = "o", col = "blue")

plot(seq(1, 10), disPare(1:10, alpha = 0.5), pch = 19, col = "red", ylim = c(0, max(disPare(1:10, alpha = 0.5), disIPare(1:10, alpha = 0.5))), xlab = "n", ylab = "P(n)")
points(seq(1, 10), disPare(1:10, alpha = 0.5), col = "black", type = "h", lty = 3)
points(seq(1, 10), disIPare(1:10, alpha = 0.5), col = "blue", pch = 19)
points(seq(1, 10), disIPare(1:10, alpha = 0.5), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(3, 0.5, pch = c(19, 19), col = c("red", "blue"),
       legend = c(expression(paste("Discrete Pareto (", alpha, " = 0.5)")), expression(paste("Discrete Inverse Pareto (", alpha, " = 0.5)"))), bty = "n", cex = 1.2)
#       legend = c("Geometric", "Inverse Geometric"), bty ="n", cex = 1.2)

plot(seq(1, 15), disParecum(1:15, alpha = 0.5), ylim = c(0, max(disParecum(1:15, alpha = 0.5), disIParecum(1:15, alpha = 0.5))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(1, 15), disIParecum(1:15, alpha = 0.5), type = "s", col = "blue")
axis(1, at = seq(1:15))
abline(v = seq(0, 10), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(5, 0.4, col = c("red", "blue"), legend = c(expression(paste("Discrete Pareto (", alpha, " = 0.5)")), expression(paste("Discrete Inverse Pareto (", alpha, " = 0.5)"))), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.3)

### Poisson
disIPois <- function(k, lambda){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
     jj[pos] <- pgamma(lambda, shape = 1/i, lower.tail = FALSE) - pgamma(lambda, shape = 1/(i + 1), lower.tail = FALSE)
  }
  return(jj)}

disIPoiscum <- function(x, lambda){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disIPois(0:i, lambda = lambda)))
  }
  return(ar)}

#plot(seq(1, 10), disG(1:10), type = "h", col = "red")
#points(seq(1, 10), disG(1:10), type = "o", col = "red")
#points(seq(1, 10), disIG(1:10), type = "o", col = "blue")

plot(seq(0, 10), dpois(0:10, lambda = 2), pch = 19, col = "red", ylim = c(0, max(dpois(0:10, lambda = 2), disIPois(0:10, lambda = 2))), xlab = "n", ylab = "P(n)")
points(seq(0, 10), dpois(0:10, lambda = 2), col = "black", type = "h", lty = 3)
points(seq(0, 10), disIPois(0:10, lambda = 2), col = "blue", pch = 19)
points(seq(0, 10), disIPois(0:10, lambda = 2), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(2, 0.6, pch = c(19, 19), col = c("red", "blue"),
       legend = c(expression(paste("Poisson (", lambda, " = 2)")), expression(paste("Discrete Inverse Poisson (", lambda, " = 2)"))), bty = "n", cex = 1.2)
#       legend = c("Geometric", "Inverse Geometric"), bty ="n", cex = 1.2)

plot(seq(0, 15), ppois(0:15, lambda = 2), ylim = c(0, max(ppois(0:15, lambda = 2), disIPoiscum(0:15, lambda = 2))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(0, 15), disIPoiscum(0:15, lambda = 2), type = "s", col = "blue")
axis(1, at = seq(1:15))
abline(v = seq(0, 10), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(5, 0.4, col = c("red", "blue"), legend = c(expression(paste("Poisson (", lambda, " = 2)")), expression(paste("Discrete Inverse Poisson (", lambda, " = 2)"))), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.4)

# Negative binomial distribution and its inverse
disINB <- function(k, r, beta){
  jj <- array(NA, dim = length(k))
  for(i in k){
    if(i == 0){
      jj[match(i, k)] <- (beta^r/(gamma(r)))*(integrate(f = function(x) pgamma(x, shape = 1/(i + 1))*x^(r - 1)*exp(-beta*x), lower = 0, upper = Inf)$value)
    }
    else{
      pos <- match(i, k)
      jj[pos] <- (beta^r/(gamma(r)))*(integrate(f = function(x) pgamma(x, shape = 1/(i + 1))*x^(r - 1)*exp(-beta*x), lower = 0, upper = Inf)$value -
        integrate(f = function(x) pgamma(x, shape = 1/i)*x^(r - 1)*exp(-beta*x), lower = 0, upper = Inf)$value )
    }
  }
  return(jj)}

disINBcum <- function(x, r, beta){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disINB(0:i, r = r, beta = beta)))
  }
  return(ar)}

#plot(seq(1, 10), disG(1:10), type = "h", col = "red")
#points(seq(1, 10), disG(1:10), type = "o", col = "red")
#points(seq(1, 10), disIG(1:10), type = "o", col = "blue")

plot(seq(0, 10), dnbinom(0:10, size = 3, prob = 2/3), pch = 19, col = "red", ylim = c(0, max(dnbinom(0:10, size = 3, prob = 2/3), disINB(0:10, r = 3, beta = 2))), xlab = "n", ylab = "P(n)")
points(seq(0, 10), dnbinom(0:10, size = 3, prob = 2/3), col = "black", type = "h", lty = 3)
points(seq(0, 10), disINB(0:10, r = 3, beta = 2), col = "blue", pch = 19)
points(seq(0, 10), disINB(0:10, r=3, beta = 2), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(1, 0.5, pch = c(19, 19), col = c("red", "blue"),
       legend = c(expression(paste("Negative Binomial (", r, " = 3, ", beta, " = 2)")), expression(paste("Inverse Negative Binomial (", r, " = 3, ", beta, " = 2)"))), bty = "n", cex = 1.2)
#       legend = c("Geometric", "Inverse Geometric"), bty ="n", cex = 1.2)

plot(seq(0, 15), pnbinom(0:15, size = 3, prob = 2/3), ylim = c(0, max(pnbinom(0:15, size = 3, prob = 2/3), disINBcum(0:15, r = 3, beta = 2))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(0, 15), disINBcum(0:15, r = 3, beta = 2), type = "s", col = "blue")
axis(1, at = seq(1:15))
abline(v = seq(0, 10), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(4, 0.4, col = c("red", "blue"), legend = c(expression(paste("Negative Binomial (", r, " = 3, ", beta, " = 2)")), expression(paste("Inverse Negative Binomial (", r, " = 3, ", beta, " = 2)"))), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.4)

# Generalized Sibuya distribution
disGS <- function(k, nu, alpha){
  ar <- array(NA, dim = length(k))
  for(i in k){
    ar[match(i, k)] <- (gamma(nu + 1)*gamma(nu + i - alpha))/(gamma(nu + 1 - alpha)*gamma(nu + i)) -
                        (gamma(nu + 1)*gamma(nu + 1+i - alpha))/(gamma(nu + 1 - alpha)*gamma(nu + 1 + i))
  }
  return(ar)}

disIGS <- function(k, nu, alpha){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
    if(i == 1){
     jj[pos] <- (gamma(nu + 1)*gamma(nu + 1 + 1/i - alpha))/(gamma(nu + 1 - alpha)*gamma(nu + 1 + 1/i))
    }
    else{
    jj[pos] <-  -( (gamma(nu + 1)*gamma(nu + 1 + 1/(i-1) - alpha ))/(gamma(nu + 1 - alpha)*gamma(nu + 1 + 1/(i-1))) -
      (gamma(nu + 1)*gamma(nu + 1 + 1/i - alpha))/(gamma(nu + 1 - alpha)*gamma(nu + 1 + 1/i)) )
    }
  }
  return(jj)}

disGScum <- function(x, nu, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- suppressWarnings(sum(disGS(k = 1:i, nu = nu, alpha = alpha)))
  }
  return(ar)}

disIGScum <- function(x, nu, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disIGS(1:i, nu = nu, alpha = alpha)))
  }
  return(ar)}

plot(seq(1, 10), disGS(1:10, nu = 2, alpha = 1.5), pch = 19, col = "red", ylim = c(0, max(disGS(1:10, nu = 2, alpha = 1.5),
                                                                                          disIGS(1:10, nu = 2, alpha = 1.5))), xlab = "n", ylab = "P(n)")
points(seq(1, 10), disGS(1:10, nu = 2, alpha = 1.5), col = "black", type = "h", lty = 3)
points(seq(1, 10), disIGS(1:10, nu = 2, alpha = 1.5), col = "blue", pch = 19)
points(seq(1, 10), disIGS(1:10, nu = 2, alpha = 1.5), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(2.5, 0.4, pch = c(19, 19), col = c("red", "blue"),
       legend = c(expression(paste("Generalized Sibuya(", nu, " = 2, ", alpha, " = 1.5)" )),
                  expression(paste("Generalized Inverse Sibuya(", nu, " = 2, ", alpha, " = 1.5)" ))), bty = "n", cex = 1.2)

plot(seq(1, 15), disGScum(1:15, nu = 2, alpha = 1.5), ylim = c(0, max(disGScum(1:15, alpha = 1.5, nu = 2), disIGScum(1:15, alpha = 1.5, nu = 2))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(1, 15), disIGScum(1:15, alpha = 1.5, nu =2), type = "s", col = "blue")
axis(1, at = seq(1:15))
abline(v = seq(0, 15), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(3, 0.4, col = c("red", "blue"), legend = c(expression(paste("Generalized Sibuya(", nu, " = 2, ", alpha, " = 1.5)" )),
                                                  expression(paste("Generalized Inverse Sibuya(", nu, " = 2, ", alpha, " = 1.5)" ))), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.3)

# logarithmic distribution
dislog <- function(k, q){
  ar <- array(NA, dim = length(k))
  for(i in k){
    ar[match(i, k)] <- - (q^i)/(log(1 - q)*i)
  }
  return(ar)}

disIlog <- function(k, q){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
    jj[pos] <- (-1/log(1 - q))*integrate(function(x){ ( x^(1/i) - x^(1/(i - 1)))/(1 - x) }, lower = 0, upper = q)$value
  }
  return(jj)}

dislogcum <- function(x, q){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- suppressWarnings(sum(dislog(k = 1:i, q = q)))
  }
  return(ar)}

disIlogcum <- function(x, q){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disIlog(1:i, q = q)))
  }
  return(ar)}

plot(seq(1, 10), dislog(1:10, q = 0.7), pch = 19, col = "red", ylim = c(0, max(dislog(1:10, q = 0.7),
                                                                                          dislog(1:10, q = 0.7))), xlab = "n", ylab = "P(n)")
points(seq(1, 10), dislog(1:10, q = 0.7), col = "black", type = "h", lty = 3)
points(seq(1, 10), disIlog(1:10, q = 0.7), col = "blue", pch = 19)
points(seq(1, 10), disIlog(1:10, q = 0.7), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(4, 0.4, pch = c(19, 19), col = c("red", "blue"), legend = c(expression(paste("logarithmic (", q," = 0.7)")),
                  expression(paste("Inverse logarithmic(", q, " = 0.7)" ))), bty = "n", cex = 1.2)

plot(seq(1, 15), dislogcum(1:15, q = 0.7), ylim = c(0, max(dislogcum(1:15, q = 0.7), disIlogcum(1:15, q = 0.7))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(1, 15), disIlogcum(1:15, q = 0.7), type = "s", col = "blue")
axis(1, at = seq(1:15))
abline(v = seq(0, 15), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(3, 0.3, col = c("red", "blue"), legend = c(expression(paste("logarithmic(", q, " = 0.7)" )),
                                                  expression(paste("Inverse logarithmic(", q, " = 0.7)" ))), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.5)


# zipf distribution
# Zeta- function
library(VGAM)
diszipf <- function(k, alpha){
  ar <- array(NA, dim = length(k))
  for(i in k){
    ar[match(i, k)] <- (1/zeta(x = alpha + 1))*((1/(i + 1))^(alpha + 1) )
  }
  return(ar)}

disIzipf <- function(k, alpha){
  jj <- array(NA, dim = length(k))
  for(i in k){
    pos <- match(i, k)
    jj[pos] <- (1/zeta(x = alpha + 1))*( zeta(x = alpha + 1, shift = ((i + 2)/(i + 1))) - zeta(x = alpha + 1, shift = ((i + 1)/(i))))
  }
  return(jj)}

diszipfcum <- function(x, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <- suppressWarnings(sum(diszipf(k = 0:i, alpha = alpha)))
  }
  return(ar)}

disIzipfcum <- function(x, alpha){
  ar <- array(NA, dim = length(x))
  for(i in x){
    ar[match(i, x)] <-suppressWarnings(sum(disIzipf(0:i, alpha = alpha)))
  }
  return(ar)}

plot(seq(0, 10), diszipf(0:10, alpha = 2), pch = 19, col = "red", ylim = c(0, max(diszipf(0:10, alpha = 2),
                                                                               diszipf(0:10, alpha = 2))), xlab = "n", ylab = "P(n)")
points(seq(0, 10), diszipf(0:10, alpha = 2), col = "black", type = "h", lty = 3)
points(seq(0, 10), disIzipf(0:10, alpha = 2), col = "blue", pch = 19)
points(seq(0, 10), disIzipf(0:10, alpha = 2), col = "black", type = "h", lty = 3)
axis(1, at = seq(1:10))
#abline(v = seq(0, 10), col = "black", lty = 3)
legend(4, 0.4, pch = c(19, 19), col = c("red", "blue"), legend = c(expression(paste("zipf (", alpha," = 2)")),
                                                                   expression(paste("Inverse zipf(", alpha, " = 2)" ))), bty = "n", cex = 1.2)

plot(seq(0, 15), diszipfcum(0:15, alpha = 2), ylim = c(0, max(diszipfcum(0:15, alpha = 2), disIzipfcum(0:15, alpha = 2))), type = "s", col = "red", xlab = "n", ylab = "F(n)")
#points(seq(1, 15), disGcum(1:15), type = "s", col = "red")
points(seq(0, 15), disIzipfcum(0:15, alpha = 2), type = "s", col = "blue")
axis(1, at = seq(0:15))
abline(v = seq(0, 15), col = "grey", lty = 3)
#abline(h = c(0, 0.2, 0.4, 0.6, 0.8, 1), col = "grey", lty = 3)
legend(3, 0.3, col = c("red", "blue"), legend = c(expression(paste("zipf(", alpha, " = 2)" )),
                                                  expression(paste("Inverse zipf(", alpha, " = 2)" ))), lty = c(1, 1), bty = "n", cex = 1.2, seg.len = 0.5)

#----------------------------------------------------------
########### Pareto-normal (symmetric cases) ###############
#-----------------------------------------------------------
library(cubature);library(rootSolve)
####---- The PDF -------#####
NP.pdf <- function(y, alpha = 0.5, sigma = 1){
  bb <- array(NA, dim = length(y))
  for(i in y){
    pos <- match(i, y)
    gg <- function(t){
      uu <- (sqrt(t/2)/sigma)*exp(-sqrt(2*t)*abs(i)/sigma)*(t^(1/alpha - 1)*exp(-t/alpha))/(alpha^(1/alpha)*gamma(1/alpha))
      return(uu)
    }
  bb[pos] <- adaptIntegrate(gg, lowerLimit = 0, upperLimit = Inf)$integral
  #bb[pos] <- integrate(gg, lower = 0, upper = Inf)$value
  }
return(bb)
}

###----- Curve for PDF -----#####
graph.f.x.NP <- function(alpha.par = 0.5, sigma.par = 1, start = -10, end = 10){
  NP.pdf <- function(y, alpha= alpha.par, sigma = sigma.par){
    bb <- array(NA, dim = length(y))
    for(i in y){
      pos <- match(i, y)
      gg <- function(t){
        uu <- (sqrt(t/2)/sigma)*exp(-sqrt(2*t)*abs(i)/sigma)*(t^(1/alpha - 1)*exp(-t/alpha))/(alpha^(1/alpha)*gamma(1/alpha))
        return(uu)
      }
      bb[pos] <- integrate(gg, lower = 0, upper = Inf)$value
    }
    return(bb)
  }
  curve(NP.pdf, from = start, to = end, ylab = "f(y)", xlab = "y", col = "blue")
  legend(x = 3, y = 0.3, legend = paste(c("alpha =", alpha.par, ";", "sigma =", sigma.par),
                                        collapse = " "), lty = 1, col =c("blue"), cex = 0.7, box.col = "white", text.width = 3)
}

graph.f.x.NP(alpha.par = 0.5, sigma.par = 1)

### PDF plots
val <- seq(-10, 10, by = 0.01)
f.1 <- NP.pdf(y = val, alpha = 0.6, sigma = 3)
f.2 <- NP.pdf(y = val, alpha = 1, sigma = 1)
f.3 <- NP.pdf(y = val, alpha = 1, sigma = 1.5)

plot(val, f.1, type = "l", col = "black", xlab = "y", ylab = "f(y)", ylim = c(0, max(f.1, f.2, f.3)))
points(val, f.2, type = "l", lty = "dotted", col = "red")
points(val, f.3, type = "l", lty = "twodash", col = "blue")
legend(x = "right", legend = c("alpha = 0.6, sigma = 3", "alpha = 1, sigma = 1",
                                    "alpha = 2, sigma = 1.5"), lty = c(1, 3, 5), col = c("black", "red", "blue"), cex = 0.7, text.width = 2.5)

###---- The CDF ------#####
NP.cdf <- function(y, alpha = 1, sigma = 1){
 bb <- array(NA, dim = length(y))
  for(i in y){
   pos <- match(i, y)
    gg <- function(t){(0.5*exp(-sqrt(2*t)*abs(i)/sigma)*t^((1/alpha) - 1)*exp(-t/alpha))/(alpha^(1/alpha)*gamma(1/alpha))}
  if(i < 0){
  bb[pos] <- integrate(gg, lower = 0, upper = Inf)$value
    }
  else if(i >= 0){
  bb[pos] <- 1 - integrate(gg, lower = 0, upper = Inf)$value
  }
 }
return(bb)
}

####----- Curve for CDF -----####
curve(NP.cdf, from = -10, to = 10, ylab = "F(y)", xlab = "y")

### Other CDFs with different parameter combinations
val <- seq(-13, 13, by = 0.01)
f.1 <- NP.cdf(y = val, alpha = 0.6, sigma = 3)
f.2 <- NP.cdf(y = val, alpha = 1, sigma = 1)
f.3 <- NP.cdf(y = val, alpha = 2, sigma = 1.5)

plot(val, f.1, type = "l", col = "black", xlab = "y", ylab = "F(y)")
points(val, f.2, type = "l", lty = "dotted", col = "red")
points(val, f.3, type = "l", lty = "twodash", col = "blue")
legend(x = 0.5, y = 0.4, legend = c("alpha = 0.6, sigma = 3", "alpha = 1, sigma = 1",
                                    "alpha = 2, sigma = 1.5"), lty = c(1, 3, 5), col = c("black", "red", "blue"), cex = 0.7, text.width = 8)

# Obtain n random samples from NP
rNPare <- function(n = 1, alpha = 0.5, sigma = 1){
    normal <- rnorm(n); exponential <- rexp(n)
    gamm <- rgamma(n, shape = 1/alpha, scale = alpha)
    y <- sigma*sqrt(exponential/gamm)*normal
    return(y)
}

# Graph overlay of numbers generated versus the density
par(mfrow = c(2, 2))

alpha.par <- 0.7; sigma.par <- 1
X <- rNPare(n = 1000, alpha = alpha.par, sigma = sigma.par)
jj <- NP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par)
hist(X, freq = FALSE, breaks = 60, ylim = c(0, max(jj)), main = "", xlab = "y")
points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
legend(x = 3, y = 0.4, legend = expression(paste(alpha, " = ", 0.7, "; ", sigma, " = ", 1)), bty = "n", cex = 1.2, text.width = 6.5 )

alpha.par <- 1; sigma.par <- 1
X <- rNPare(n = 1000, alpha = alpha.par, sigma = sigma.par)
jj <- NP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par)
hist(X, freq = FALSE, breaks = 60, ylim = c(0, max(jj)), main = "", xlab = "y")
points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
legend(x = 3, y = 0.4, legend = expression(paste(alpha, " = ", 1, "; ", sigma, " = ", 1)), bty = "n", cex = 1.2, text.width = 6.5 )

#alpha.par <- 2; sigma.par <- 1
#X <- rNPare(n = 300, alpha = alpha.par, sigma = sigma.par)
#jj <- NP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par)
#hist(X, freq = FALSE, breaks = 120, ylim = c(0, max(jj)), main = "", xlab = "y")
#points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
#legend(x = -400, y = 0.4, legend = expression(paste(alpha, " = ", 2, "; ", sigma, " = ", 1)), bty = "n", cex = 1.2, text.width = 6.5 )

alpha.par <- 0.7; sigma.par <- 5
X <- rNPare(n = 1000, alpha = alpha.par, sigma = sigma.par)
jj <- NP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par)
hist(X, freq = FALSE, breaks = 60, ylim = c(0, max(jj)), main = "", xlab = "y")
points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
legend(x = -100, y = 0.06, legend = expression(paste(alpha, " = ", 0.7, "; ", sigma, " = ", 5)), bty = "n", cex = 1.2, text.width = 6.5 )

alpha.par <- 1; sigma.par <- 5
X <- rNPare(n = 1000, alpha = alpha.par, sigma = sigma.par)
jj <- NP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par)
hist(X, freq = FALSE, breaks = 60, ylim = c(0, max(jj)), main = "", xlab = "y")
points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
legend(x = -100, y = 0.06, legend = expression(paste(alpha, " = ", 1, "; ", sigma, " = ", 5)), bty = "n", cex = 1.2, text.width = 6.5 )

par(mfrow = c(1, 1))


#####------------ Quantile Function -----------------######
NP.quantile <- function(alpha = 0.5, sigma = 1, u = 0.01){
  ahy <- array(NA, dim = length(u))
  for(i in u){
  pos <- match(i, u)

  g.y.1 <- function(y){
    fin <- NP.cdf(y = y, alpha = alpha, sigma = sigma) - i
    return(fin)
  }
  ahy[pos] <- uniroot(g.y.1, lower = -0.001, upper = 100, extendInt = "yes")$root
  }
  return(ahy)
}

# A graph of the quantile function
plot(x = seq(0.01, 0.99, 0.01), y = NP.quantile(u = seq(0.01, 0.99, 0.01)), type = "l", xlab = "u", ylab = "Quantile")

emp.cdf <- function(data, cor = 0.25){
  s <- sort(data); n <- length(data)
  uni <- unique(sort(data))
  cdf <- array(NA, dim = length(uni))
  for(i in uni){
   pos <- match(i, uni)
   cdf[pos] <- length(which(s <= i))/(n + cor )
  }
  return(data.frame(X = uni, Empirical_CDF = cdf))
}

QQ.plot.y <- function(data, alpha.est, sigma.est, corr = 0.25){
  jj <- emp.cdf(data, cor = corr)
  mm <- array(NA, dim = length(jj$X))
  for(i in jj$Empirical_CDF){
    pos <- match(i, jj$Empirical_CDF)
    mm[pos] <- NP.quantile(u = i, alpha = alpha.est, sigma = sigma.est)
  }
  plot(mm, jj$X, xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
   #    main = "Normal-Pareto Q-Q Plot")
  abline(a = 0, b = 1, col = "red")
}

###------ Estimation procedures -------###
##### MME
lmix.MME <- function(obser.y){
  require(rootSolve)
  f.alpha <- function(alpha){
    C.1 <- 0.5*log(2) + 0.5*digamma(0.5) + 0.5*digamma(1)
    C.2 <- (gamma(3/4)*gamma(1/4))/(sqrt(pi)*(2^0.25))
    res <- 2*lgamma((1/alpha) + 0.25) - 2*lgamma(1/alpha) -
      0.5*digamma(1/alpha) -
      mean(log(abs(obser.y))) + C.1 +
      2*log(C.2/mean(abs(obser.y)^(-0.5)))
    return(res)
  }
  R.fun <- function(cc){
    C.1 <- 0.5*(log(2) + digamma(1/2) + digamma(1))
    C.2 <- (gamma(0.75)*gamma(0.25))/(sqrt(pi)*(2^0.25))
    ves <- mean(log(abs(cc))) - C.1 -
      2*log( C.2/mean(abs(cc)^(-0.5)))
    return(ves)
  }

  if(R.fun(obser.y) > 0){
    out.alpha <- uniroot(f.alpha, lower = 0.01,
                         upper = 100, extendInt = 'yes')$root
    C.2 <- (gamma(3/4)*gamma(1/4))/(sqrt(pi)*(2^0.25))
    out.sigma <- exp(2*(log(((out.alpha^(0.25))/mean(abs(obser.y)^(-0.5)))*C.2) +
                          lgamma( (1/out.alpha) + 0.25) - lgamma(1/out.alpha)))
    out <- c(alpha = out.alpha, sigma = out.sigma, R.value = R.fun(obser.y))
    return(out)
  }
  else{
    out.alpha <- 0
    C.2 <- (gamma(3/4)*gamma(1/4))/(sqrt(pi)*(2^0.25))
    out.sigma <-  (C.2/mean((abs(obser.y)^(-0.5))))^2
    out <- c(alpha = out.alpha, sigma = out.sigma, R.value = R.fun(obser.y))
    return(out)
  }
}

0########## Normal Pareto Generator ###################
rNPare <- function(n = 1, alpha = 0.5, sigma = 1){
  normal <- rnorm(n); exponential <- rexp(n)
  gamm <- rgamma(n, shape = 1/alpha, scale = alpha)
  y <- sigma*sqrt(exponential/gamm)*normal
  return(y)
}

########################## MME case 1 sigma unknown but alpha known ##########################
MME.case1.sigma <- function(alpha, data){
  fin <- (gamma(3/4)*gamma(1/4)*gamma(1/alpha + 0.25)*(alpha^0.25)/(2^0.25 * sqrt(pi)*gamma(1/alpha)*mean( abs(data)^(-0.5))))^2
  return(fin)
}

MME.case1.sigma(data = rNPare(5000), alpha = 0.5) # An example

sim.MME.case1.sigma <- function(k = 1000, alpha = 0.5, sigma = 1, num = 10){
  num.vec <- matrix(NA, nrow = k, ncol = 5)
  colnames(num.vec) <- c("Sample", "alpha", "sigma", "Estimate", "RelativeError")
  num.vec[ , 1] <- rep(num, k)
  num.vec[ , 2] <- rep(alpha, k)
  num.vec[ , 3] <- rep(sigma, k)

  # Generate independent Y's
  for(i in 1:k){
    cc <- rNPare(n = num, alpha = alpha, sigma = sigma)
    num.vec[i, 4] <- MME.case1.sigma(alpha = alpha, data = cc)
    num.vec[i, 5] <- (num.vec[i, 4] - num.vec[i, 3])/num.vec[i, 3]
  }
  #  return(data.frame(num.vec))
  return(data.frame(num.vec))
}

l <- rbind(sim.MME.case1.sigma(alpha = 0.7, sigma = 0.5, num = 50), sim.MME.case1.sigma(alpha = 0.7, sigma = 0.5, num = 150), sim.MME.case1.sigma(alpha = 0.7, sigma = 0.5, num = 300),
           sim.MME.case1.sigma(alpha = 1, sigma = 1, num = 50), sim.MME.case1.sigma(alpha = 1, sigma = 1, num = 150), sim.MME.case1.sigma(alpha = 1, sigma = 1, num = 300),
           sim.MME.case1.sigma(alpha = 2, sigma = 5, num = 50), sim.MME.case1.sigma(alpha = 2, sigma = 5, num = 150), sim.MME.case1.sigma(alpha = 2, sigma = 5, num = 300),
           sim.MME.case1.sigma(alpha = 1, sigma = 0.5, num = 50), sim.MME.case1.sigma(alpha = 2, sigma = 0.5, num = 50), sim.MME.case1.sigma(alpha = 1, sigma = 0.5, num = 150),
           sim.MME.case1.sigma(alpha = 2, sigma = 0.5, num = 150), sim.MME.case1.sigma(alpha = 1, sigma = 0.5, num = 300), sim.MME.case1.sigma(alpha = 2, sigma = 0.5, num = 300),
           sim.MME.case1.sigma(alpha = 0.7, sigma = 1, num = 50), sim.MME.case1.sigma(alpha = 2, sigma = 1, num = 50), sim.MME.case1.sigma(alpha = 0.7, sigma = 1, num = 150),
           sim.MME.case1.sigma(alpha = 2, sigma = 1, num = 150), sim.MME.case1.sigma(alpha = 0.7, sigma = 1, num = 300), sim.MME.case1.sigma(alpha = 2, sigma = 1, num = 300),
           sim.MME.case1.sigma(alpha = 0.7, sigma = 5, num = 50), sim.MME.case1.sigma(alpha = 1, sigma = 5, num = 50), sim.MME.case1.sigma(alpha = 0.7, sigma = 5, num = 150),
           sim.MME.case1.sigma(alpha = 1, sigma = 5, num = 150), sim.MME.case1.sigma(alpha = 0.7, sigma = 5, num = 300), sim.MME.case1.sigma(alpha = 1, sigma = 5, num = 300))

save(l, file = "MME.case1.sigma.1000.simulations.RData")

library(ggplot2)
# Relative error graphs
gh <- ggplot(l, aes(x = RelativeError)) + geom_histogram(aes(y = ..density..)) + facet_grid(sigma ~ Sample + alpha, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = Estimate)) + geom_boxplot() + geom_hline(aes(yintercept = sigma), color = "red") +
      facet_wrap(sigma ~ alpha, scales = "free", labeller = label_both) + labs(x = "Sample size") + theme_classic()
th

# Generating table
tab1 <- l[which(l$Sample == 50 & l$sigma == 0.5 & l$alpha == 0.7), ]
(esti <- round(mean(tab1$Estimate), 4))
(MSE <- round(mean( (tab1$sigma - tab1$Estimate)^2 ), 4 ))

tab1 <- l[which(l$Sample == 300 & l$sigma == 5 & l$alpha == 2), ]
(esti <- round(mean(tab1$Estimate), 4 ))
(MSE <- round(mean( (tab1$sigma - tab1$Estimate)^2 ), 4 ))

f <- function(alpha){
  h <- log(alpha) + digamma(1/alpha)
  return(h)
}

curve(f, from = 0.01, to = 70)

g <- function(z){
  h <- (gamma(z + 0.25)/gamma(z))/(z^0.25)
  return(h)
}

curve(g, from = 0.001, to = 10000, xlab = expression(paste(alpha)), ylab = expression(paste("G(",alpha,")")))

##################### MME case 2 sigma unknown ########################
library(rootSolve)
MME.case2.alpha <- function(sigma, data){
  fin <- function(alpha){
    h <- log(alpha) + digamma(1/alpha) - 2*log(sigma) - digamma(1) - log(2) - digamma(1/2) + 2*mean(log(abs(data)))
    return(h)
  }
  return(uniroot(fin, lower = 0.01, upper = 100, extendInt = "yes")$root)
}

MME.case2.alpha(data = rNPare(500, alpha = 2), sigma = 1) # An example

sim.MME.case2.alpha <- function(k = 8000, alpha = 0.5, sigma = 1, num = 10){
  num.vec <- matrix(NA, nrow = k, ncol = 5)
  colnames(num.vec) <- c("Sample", "alpha", "sigma", "Estimate", "RelativeError")
  num.vec[ , 1] <- rep(num, k)
  num.vec[ , 2] <- rep(alpha, k)
  num.vec[ , 3] <- rep(sigma, k)

  # Generate independent Y's
  for(i in 1:k){
    cc <- rNPare(n = num, alpha = alpha, sigma = sigma)
    y <- suppressWarnings(try(MME.case2.alpha(alpha = alpha, data = cc)))
    if(y == "try-error"){
      num.vec[i, 4] <- NA
    }
    else{
      q <- suppressWarnings(try(x <- MME.case2.alpha(sigma = sigma, data = cc)))
        if(class(q) != "try-error"){
          num.vec[i, 4] <- q
        }
      }
    num.vec[i, 5] <- (num.vec[i, 4] - num.vec[i, 2])/num.vec[i, 2]
  }
  v <- data.frame(num.vec)
  v <- v[complete.cases(v), ]
  v <- v[1:1000, ]
  return(v)
}

l <- rbind(sim.MME.case2.alpha(alpha = 0.7, sigma = 0.5, num = 50), sim.MME.case2.alpha(alpha = 0.7, sigma = 0.5, num = 150), sim.MME.case2.alpha(alpha = 0.7, sigma = 0.5, num = 300),
           sim.MME.case2.alpha(alpha = 1, sigma = 1, num = 50), sim.MME.case2.alpha(alpha = 1, sigma = 1, num = 150), sim.MME.case2.alpha(alpha = 1, sigma = 1, num = 300),
           sim.MME.case2.alpha(alpha = 2, sigma = 5, num = 50), sim.MME.case2.alpha(alpha = 2, sigma = 5, num = 150), sim.MME.case2.alpha(alpha = 2, sigma = 5, num = 300),
           sim.MME.case2.alpha(alpha = 1, sigma = 0.5, num = 50), sim.MME.case2.alpha(alpha = 2, sigma = 0.5, num = 50), sim.MME.case2.alpha(alpha = 1, sigma = 0.5, num = 150),
           sim.MME.case2.alpha(alpha = 2, sigma = 0.5, num = 150), sim.MME.case2.alpha(alpha = 1, sigma = 0.5, num = 300), sim.MME.case2.alpha(alpha = 2, sigma = 0.5, num = 300),
           sim.MME.case2.alpha(alpha = 0.7, sigma = 1, num = 50), sim.MME.case2.alpha(alpha = 2, sigma = 1, num = 50), sim.MME.case2.alpha(alpha = 0.7, sigma = 1, num = 150),
           sim.MME.case2.alpha(alpha = 2, sigma = 1, num = 150), sim.MME.case2.alpha(alpha = 0.7, sigma = 1, num = 300), sim.MME.case2.alpha(alpha = 2, sigma = 1, num = 300),
           sim.MME.case2.alpha(alpha = 0.7, sigma = 5, num = 50), sim.MME.case2.alpha(alpha = 1, sigma = 5, num = 50), sim.MME.case2.alpha(alpha = 0.7, sigma = 5, num = 150),
           sim.MME.case2.alpha(alpha = 1, sigma = 5, num = 150), sim.MME.case2.alpha(alpha = 0.7, sigma = 5, num = 300), sim.MME.case2.alpha(alpha = 1, sigma = 5, num = 300))

save(l, file = "MME.case2.alpha.unknown.RData")

library(ggplot2)
# Relative error graphs
gh <- ggplot(l, aes(x = RelativeError)) + geom_histogram(aes(y = ..density..)) + facet_grid( alpha ~ sigma + Sample, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh


# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = Estimate)) + geom_boxplot() + geom_hline(aes(yintercept = alpha), color = "red") +
  facet_wrap(alpha ~ sigma, scales = "free", labeller = label_both) + labs(x = "Sample size") + theme_classic()
th

# Generating table
tab1 <- l[which(l$Sample == 50 & l$sigma == 0.5 & l$alpha == 0.7), ]
(esti <- round(mean(tab1$Estimate), 4 ))
(MSE <- round(mean( (tab1$alpha - tab1$Estimate)^2 ), 4 ))

tab1 <- l[which(l$Sample == 300 & l$sigma == 5 & l$alpha == 2), ]
(esti <- round(mean(tab1$Estimate), 4 ))
(MSE <- round(mean( (tab1$alpha - tab1$Estimate)^2 ), 4 ))


# Constant is negative addressed proportion of zeros
delta <- function(sigma, alpha, size = 10){
  ikr <- log(2*(sigma^2)) + digamma(1) + digamma(1/2) - 2*mean(log(abs(rNPare(n=size, alpha = alpha, sigma = sigma))))
  return(ikr)
}

ty.delta <- function(alpha, sigma, n = 100, k = 10000){
  num.vec <- matrix(NA, nrow = k, ncol = 4)
  colnames(num.vec) <- c("sigma", "alpha", "sample size", "delta < 0")
  num.vec[ , 1] <- rep(sigma, k)
  num.vec[ , 2] <- rep(alpha, k)
  num.vec[ , 3] <- rep(n, k)

  for(i in 1:k){
    if(delta(alpha = alpha, sigma = sigma, size = n) < 0){num.vec[i, 4] <- "Yes" }
    else{num.vec[i, 4] <- "No"}
  }
  data.frame(sigma = num.vec[ , 1], alpha = num.vec[ , 2], sampleSize = num.vec[ , 3], Negative_delta_Value = num.vec[ ,4] )
}

l <- rbind(ty.delta(alpha = 0.7, sigma = 0.5, n = 50), ty.delta(alpha = 0.7, sigma = 0.5, n = 150), ty.delta(alpha = 0.7, sigma = 0.5, n = 300),
           ty.delta(alpha = 0.7, sigma = 1, n = 50), ty.delta(alpha = 0.7, sigma = 1, n = 150), ty.delta(alpha = 0.7, sigma = 1, n = 300),
           ty.delta(alpha = 0.7, sigma = 5, n = 50), ty.delta(alpha = 0.7, sigma = 5, n = 150), ty.delta(alpha = 0.7, sigma = 5, n = 300),
           ty.delta(alpha = 1, sigma = 0.5, n = 50), ty.delta(alpha = 1, sigma = 0.5, n = 150), ty.delta(alpha = 1, sigma = 0.5, n = 300),
           ty.delta(alpha = 1, sigma = 1, n = 50), ty.delta(alpha = 1, sigma = 1, n = 150), ty.delta(alpha = 1, sigma = 1, n = 300),
           ty.delta(alpha = 1, sigma = 5, n = 50), ty.delta(alpha = 1, sigma = 5, n = 150), ty.delta(alpha = 1, sigma = 5, n = 300),
           ty.delta(alpha = 2, sigma = 0.5, n = 50), ty.delta(alpha = 2, sigma = 0.5, n = 150), ty.delta(alpha = 2, sigma = 0.5, n = 300),
           ty.delta(alpha = 2, sigma = 1, n = 50), ty.delta(alpha = 2, sigma = 1, n = 150), ty.delta(alpha = 2, sigma = 1, n = 300),
           ty.delta(alpha = 2, sigma = 5, n = 50), ty.delta(alpha = 2, sigma = 5, n = 150), ty.delta(alpha = 2, sigma = 5, n = 300))

library(ggplot2)

#level_order <- c('50', '150', '300')
#lvl1 <- c('0.7', '1', '2')
#lvl2 <- c('0.5', '1', '5')
gh <- ggplot(l, aes(fill = Negative_delta_Value, x = factor(sampleSize, levels = level_order))) +
  geom_bar( ) + facet_wrap(sigma~ alpha, labeller = label_both ) + xlab("Sample size") + ylab("Number of simulations") +
  guides(fill=guide_legend(title=expression(paste(delta, " < 0")))) + theme_classic()

save(l, file = "MME_case2_delta_countings.RData")

#gh <- ggplot(l, aes(fill = Negative_delta_Value, x = factor(sampleSize, levels = level_order))) +
#  geom_bar( ) + facet_grid(~ factor(alpha, levels = lvl), labeller = label_value) + xlab("Sample size") + ylab("Number of simulations") +
#  guides(fill=guide_legend(title="Positive R value")) + theme_classic()


######## Case 3: MME where sigma and alpha are unknown #################
MME.case3.alpha.sigma <- function(data){
  R <- mean( log(abs(data)) ) - 0.5*(log(2) + digamma(1/2) + digamma(1)) - 2*log(gamma(3/4)*gamma(1/4)/(sqrt(pi)*(2^0.25)*mean(abs(data)^(-0.5))))

  fin <- function(alpha){
    h <- 0.5*(log(1/alpha) - digamma(1/alpha)) + 2*log((alpha^0.25)*gamma(1/alpha + 0.25)/gamma(1/alpha)) - R
    return(h)
  }
  alpha <- uniroot(fin, lower = 0.01, upper = 100, extendInt = "yes")$root
  sigma <- ( (alpha^0.25 * gamma(1/alpha + 0.25)*gamma(3/4)*gamma(1/4)  )/(mean(abs(data)^(-0.5))*gamma(1/2)*(2^0.25)*gamma(1/alpha)))^2
  return(c(alpha, sigma))
}

sim.MME.case3.alpha.sigma <- function(k = 8000, alpha = 0.5, sigma = 1, num = 10, dat.num = 1){
  num.vec <- matrix(NA, nrow = 2*k, ncol = 5)
  num.vec[ , 1] <- rep(num, 2*k)
  num.vec[ , 2] <- c(rep("alpha", k), rep("sigma", k))
  num.vec[ , 3] <- c(rep(alpha, k), rep(sigma, k))

  # Generate independent Y's
  for(i in 1:k){
    cc <- rNPare(n = num, alpha = alpha, sigma = sigma)
    y <- suppressWarnings(try(MME.case3.alpha.sigma(data = cc)))
    if(class(y) == "try-error"){
      num.vec[i, 4] <- NA
    }
    else{
      q <- suppressWarnings(try(x <- MME.case3.alpha.sigma(data = cc)))
      if(class(q) != "try-error"){
      #  parameter1[i] <- q[1]; parameter2[i] <- q[2]
      num.vec[i, 4] <- q[1]; num.vec[i+k, 4] <- q[2]
      }
    }
   num.vec[i, 5] <- (as.numeric(num.vec[i, 4]) - as.numeric(num.vec[i, 3]) )/ as.numeric(num.vec[i, 3])
   num.vec[i+k, 5] <- (as.numeric(num.vec[i+k, 4]) - as.numeric(num.vec[i+k, 3]))/as.numeric(num.vec[i+k, 3])
  }
  num.vec <- num.vec[complete.cases(num.vec), ]
  num.vec <- cbind(num.vec, paste("Simulation set", dat.num))
  colnames(num.vec) <- c("Sample", "Parameter", "True", "Estimate", "RelativeError", "SetNumber")
  num.vec <- num.vec[1:1000, ]
  return(data.frame(num.vec))
}

l <- rbind(sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 0.5, num = 50, dat.num = 1), sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 0.5, num = 150,dat.num = 2), sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 0.5, num = 300, dat.num = 3),
           sim.MME.case3.alpha.sigma(alpha = 1, sigma = 1, num = 50, dat.num = 4), sim.MME.case3.alpha.sigma(alpha = 1, sigma = 1, num = 150, dat.num = 5), sim.MME.case3.alpha.sigma(alpha = 1, sigma = 1, num = 300, dat.num = 6),
           sim.MME.case3.alpha.sigma(alpha = 2, sigma = 5, num = 50, dat.num = 7), sim.MME.case3.alpha.sigma(alpha = 2, sigma = 5, num = 150, dat.num = 8), sim.MME.case3.alpha.sigma(alpha = 2, sigma = 5, num = 300, dat.num = 9),
           sim.MME.case3.alpha.sigma(alpha = 1, sigma = 0.5, num = 50, dat.num = 10), sim.MME.case3.alpha.sigma(alpha = 2, sigma = 0.5, num = 50, dat.num = 11), sim.MME.case3.alpha.sigma(alpha = 1, sigma = 0.5, num = 150, dat.num = 12),
           sim.MME.case3.alpha.sigma(alpha = 2, sigma = 0.5, num = 150, dat.num = 13), sim.MME.case3.alpha.sigma(alpha = 1, sigma = 0.5, num = 300, dat.num = 14), sim.MME.case3.alpha.sigma(alpha = 2, sigma = 0.5, num = 300, dat.num = 15),
           sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 1, num = 50, dat.num = 16), sim.MME.case3.alpha.sigma(alpha = 2, sigma = 1, num = 50, dat.num = 17), sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 1, num = 150, dat.num = 18),
           sim.MME.case3.alpha.sigma(alpha = 2, sigma = 1, num = 150, dat.num = 19), sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 1, num = 300, dat.num = 20), sim.MME.case3.alpha.sigma(alpha = 2, sigma = 1, num = 300, dat.num = 21),
           sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 5, num = 50, dat.num = 22), sim.MME.case3.alpha.sigma(alpha = 1, sigma = 5, num = 50, dat.num = 23), sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 5, num = 150, dat.num =24),
           sim.MME.case3.alpha.sigma(alpha = 1, sigma = 5, num = 150, dat.num = 25), sim.MME.case3.alpha.sigma(alpha = 0.7, sigma = 5, num = 300, dat.num = 26), sim.MME.case3.alpha.sigma(alpha = 1, sigma = 5, num = 300, dat.num = 27))

save(l, file = "MME.case3.alpha.sigma.RData")

library(ggplot2)
# Relative error graphs
gh <- ggplot(l, aes(x = RelativeError)) + geom_histogram(aes(y = ..density..)) + facet_grid( alpha ~ sigma + Sample, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = Estimate)) + geom_boxplot() + geom_hline(aes(yintercept = alpha), color = "red") +
  facet_wrap(alpha ~ sigma, scales = "free", labeller = label_both) + labs(x = "Sample size") + theme_classic()
th

th <- ggplot(l, aes(x = as.factor(Sample), y = Estimate)) + geom_boxplot() + facet_wrap(al)



+ geom_boxplot() + geom_hline(aes(yintercept = alpha), color = "red") +
  facet_wrap(alpha ~ sigma, scales = "free", labeller = label_both) + labs(x = "Sample size") + theme_classic()
th


sim.MME.case3.alpha.sigma.unknown <- function(k = 8000, alpha = 0.5, sigma = 1, num = 10){
  num.vec <- matrix(NA, nrow = k, ncol = 7)
  num.vec[ , 1] <- rep(num, k)
  num.vec[ , 2] <- rep(alpha, k)
  num.vec[ , 3] <- rep(sigma, k)

  # Generate independent Y's
  for(i in 1:k){
    cc <- rNPare(n = num, alpha = alpha, sigma = sigma)
    y <- suppressWarnings(try(MME.case3.alpha.sigma(data = cc)))
    if(class(y) == "try-error"){
      num.vec[i, 4] <- NA
    }
    else{
      q <- suppressWarnings(try(x <- MME.case3.alpha.sigma(data = cc)))
      if(class(q) != "try-error"){
        num.vec[i, 4] <- q[1]; num.vec[i, 5] <- q[2]
      }
    }
    num.vec[i, 6] <- (as.numeric(num.vec[i, 4]) - as.numeric(num.vec[i, 2]) )/ as.numeric(num.vec[i, 2])
    num.vec[i, 7] <- (as.numeric(num.vec[i, 5]) - as.numeric(num.vec[i, 3]))/as.numeric(num.vec[i, 3])
  }
  num.vec <- num.vec[complete.cases(num.vec), ]
  colnames(num.vec) <- c("Sample", "Alpha", "Sigma", "EstimateAlpha", "EstimateSigma", "RelativeErrorAlpha", "RelativeErrorSigma")
  num.vec <- num.vec[1:1000, ]
  return(data.frame(num.vec))
}

l <- rbind(sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 0.5, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 0.5, num = 150), sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 0.5, num = 300),
           sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 1, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 1, num = 150), sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 1, num = 300),
           sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 5, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 5, num = 150), sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 5, num = 300),
           sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 0.5, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 0.5, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 0.5, num = 150),
           sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 0.5, num = 150), sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 0.5, num = 300), sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 0.5, num = 300),
           sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 1, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 1, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 1, num = 150),
           sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 1, num = 150), sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 1, num = 300), sim.MME.case3.alpha.sigma.unknown(alpha = 2, sigma = 1, num = 300),
           sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 5, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 5, num = 50), sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 5, num = 150),
           sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 5, num = 150), sim.MME.case3.alpha.sigma.unknown(alpha = 0.7, sigma = 5, num = 300), sim.MME.case3.alpha.sigma.unknown(alpha = 1, sigma = 5, num = 300))

save(l, file = "MME.case3.alpha.sigma.1000.RData")

library(ggplot2)
# Plots for alpha
# Relative error graphs
gh <- ggplot(l, aes(x = RelativeErrorAlpha)) + geom_histogram(aes(y = ..density..)) + facet_grid( Alpha ~ Sigma + Sample, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = EstimateAlpha)) + geom_boxplot() + geom_hline(aes(yintercept = Alpha), color = "red") +
  facet_wrap(Alpha ~ Sigma, scales = "free", labeller = label_both) + labs(x = "Sample size", y = expression(paste("Estimate ", alpha))) + theme_classic()
th

# Plots for sigma
gh <- ggplot(l, aes(x = RelativeErrorSigma)) + geom_histogram(aes(y = ..density..)) + facet_grid(Alpha ~ Sigma + Sample, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = EstimateSigma)) + geom_boxplot() + geom_hline(aes(yintercept = Sigma), color = "red") +
  facet_wrap(Alpha ~ Sigma, scales = "free", labeller = label_both) + labs(x = "Sample size", y = expression(paste("Estimate ", sigma))) + theme_classic()
th

# Generating table
tab1 <- l[which(l$Alpha == 0.7 & l$Sigma == 0.5 & l$Sample == 50), ]
(esti_alpha <- round(mean(tab1$EstimateAlpha), 4 ))
(esti_sigma <- round(mean(tab1$EstimateSigma), 4))
(MSE <- round(mean( (tab1$Alpha - tab1$EstimateAlpha)^2 ), 4 ))
(MSE <- round(mean( (tab1$Sigma - tab1$EstimateSigma)^2 ), 4 ))

tab1 <- l[which(l$Alpha == 2 & l$Sigma == 5 & l$Sample == 300), ]
(esti_alpha <- round(mean(tab1$EstimateAlpha), 4 ))
(esti_sigma <- round(mean(tab1$EstimateSigma), 4))
(MSE <- round(mean( (tab1$Alpha - tab1$EstimateAlpha)^2 ), 4 ))
(MSE <- round(mean( (tab1$Sigma - tab1$EstimateSigma)^2 ), 4 ))


library(cubature)
########## Normal Pareto Generator ###################
rNPare <- function(n = 1, alpha = 0.5, sigma = 1){
  normal <- rnorm(n); exponential <- rexp(n)
  gamm <- rgamma(n, shape = 1/alpha, scale = alpha)
  y <- sigma*sqrt(exponential/gamm)*normal
  return(y)
}

########## PDF for Normal Pareto #####################
NP.pdf <- function(y, alpha = 0.5, sigma = 1){
  bb <- array(NA, dim = length(y))
  for(i in y){
    pos <- match(i, y)
    gg <- function(t){
      uu <- (sqrt(t/2)/abs(sigma))*exp(-sqrt(2*t)*abs(i)/abs(sigma))*(t^(1/abs(alpha) - 1)*exp(-t/abs(alpha)))/(abs(alpha)^(1/abs(alpha))*gamma(1/abs(alpha)))
      return(uu)
    }
    bb[pos] <- adaptIntegrate(gg, lowerLimit = 0, upperLimit = Inf)$integral
  }
  return(bb)}

########### MLE estimation using EM Algorithm ########
# Case 1 sigma unknown, alpha known
EM.case.1.sigma <- function(data, tol = 1e-2, maxiter = 500, sigma = 1, alpha = 1, verb = FALSE){
  #------------------------- First space (checking input errors) ----------------------------------------#
  if(!is.numeric(sigma) | !is.numeric(tol) | !is.numeric(data)) stop(
    "arguments 'y', 'tol', 'maxiter', 'sigma' must be numeric")
  if(sigma <= 0) stop("alpha and sigma must be positive")
  #######################################################################################################
  #---------------------------- Second space (necessary functions) --------------------------------------#
  log_like <- function(iter.alpha = alpha, iter.sigma){
    sum(log(NP.pdf(data, alpha = iter.alpha, sigma = iter.sigma)))}

  # function to compute all expectations
  all.expectations <- function(iter.sigma, iter.alpha = alpha){
    b_k <- array(NA, dim = length(data))
    for(y_i in data){
      fun.1 <- function(t) (sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.3 <- function(t) sqrt(t)*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))

      dens.y <- adaptIntegrate(fun.1, lowerLimit = 0, upperLimit = Inf)$integral
      b.exp <- adaptIntegrate(fun.3, lowerLimit = 0, upperLimit = Inf)$integral/dens.y

      pos <- match(y_i, data)
      b_k[pos] <- b.exp
    }
    dat <- data.frame(b_k)
    return(dat)}
  #####################################################
  #### E step
  expect <- all.expectations(iter.sigma = sigma)
  b_old <- expect$b_k
  ll_old <- log_like(iter.sigma = sigma)
  k = 0
  sigma_old <- sigma
  output <- c(k, sigma_old, ll_old)
  diff <- tol + 1

  while((diff > tol) & (k < maxiter)){
    #### M step
    sigma <- sqrt(2)*mean(b_old*abs(data))
    expect <- all.expectations(iter.sigma = sigma)
    b_old <- expect$b_k
    ll_new <- log_like(iter.sigma = sigma)
    diff <- ll_new - ll_old
    ll_old <- ll_new
    k <- k + 1
    output <- rbind(output, c(k, sigma, ll_new))
    if(verb){
      cat("iteration =", k, " log.lik.diff =", diff, " log.lik =",
          ll_new, "\n")}

    if(k == maxiter){
      cat("Warning! Convergence not achieved!", "\n")
    }
    output <- data.frame(output)
    colnames(output) <- c("iteration","sigma","log-lik")
    par <- data.frame(t(c(sigma)))
    colnames(par) <- c("sigma")
    result <- list(par=par, log.like = ll_new, iterations=k, output=output)
  }
  return(result)
}

# Iteration plots
rt1 <- rNPare(n = 1000, alpha = 1, sigma = 0.5)
rt2 <- rNPare(n = 1000, alpha = 1, sigma = 1)
rt3 <- rNPare(n = 1000, alpha = 1, sigma = 5)

l1 <- EM.case.1.sigma(data = rt1, alpha = 1, sigma = 0.2)
l2 <- EM.case.1.sigma(data = rt1, alpha = 1, sigma = MME.case1.sigma(alpha = 1, data = rt1))
l3 <- EM.case.1.sigma(data = rt1, alpha = 1, sigma = 1.5 )

plot(l1$output$iteration, l1$output$sigma, ylim = c(0, max(l1$output$sigma,l2$output$sigma,l3$output$sigma)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(sigma, " values")))
points(l2$output$iteration, l2$output$sigma, type = "o", pch = 19, col = "blue")
points(l3$output$iteration, l3$output$sigma, type = "o", col = "green", pch = 19)
abline(h = 0.5, col = "red", lty = 2)
legend(4, 1.2, legend = c("Intial values", expression(paste(sigma, " = 0.3075 (MME)" )),
                          expression(paste(sigma, " = 1.5" )), expression(paste(sigma, " = 0.2"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

m1 <- EM.case.1.sigma(data = rt2, alpha = 1, sigma = 0.2, tol = 1e-4)
m2 <- EM.case.1.sigma(data = rt2, alpha = 1, sigma = MME.case1.sigma(alpha = 1, data = rt2), tol = 1e-4)
m3 <- EM.case.1.sigma(data = rt2, alpha = 1, sigma = 1.5, tol = 1e-4)

plot(m1$output$iteration, m1$output$sigma, ylim = c(0, max(m1$output$sigma,m2$output$sigma,m3$output$sigma)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(sigma, " values")))
points(m2$output$iteration, m2$output$sigma, type = "o", pch = 19, col = "blue")
points(m3$output$iteration, m3$output$sigma, type = "o", col = "green", pch = 19)
abline(h = 1, col = "red", lty = 2)
legend(6, 0.7, legend = c("Intial values", expression(paste(sigma, " = 1.2481 (MME)" )),
                          expression(paste(sigma, " = 1.5" )), expression(paste(sigma, " = 0.2"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

n1 <- EM.case.1.sigma(data = rt3, alpha = 1, sigma = 0.2, tol = 1e-4)
n2 <- EM.case.1.sigma(data = rt3, alpha = 1, sigma = MME.case1.sigma(alpha = 1, data = rt3), tol = 1e-4)
n3 <- EM.case.1.sigma(data = rt3, alpha = 1, sigma = 10, tol = 1e-4)

plot(n1$output$iteration, n1$output$sigma, ylim = c(0, max(n1$output$sigma,n2$output$sigma,n3$output$sigma)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(sigma, " values")))
points(n2$output$iteration, n2$output$sigma, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$sigma, type = "o", col = "green", pch = 19)
abline(h = 5, col = "red", lty = 2)
legend(6, 8, legend = c("Intial values", expression(paste(sigma, " = 3.3465 (MME)")),
                          expression(paste(sigma, " = 10" )), expression(paste(sigma, " = 0.2"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

sim.MLE.case1.sigma <- function(k = 1000, alpha = 0.5, sigma = 1, num = 10){
  num.vec <- matrix(NA, nrow = k, ncol = 5)
  colnames(num.vec) <- c("Sample", "alpha", "sigma", "Estimate", "RelativeError")
  num.vec[ , 1] <- rep(num, k)
  num.vec[ , 2] <- rep(alpha, k)
  num.vec[ , 3] <- rep(sigma, k)

  # Generate independent Y's
  for(i in 1:k){
    cc <- rNPare(n = num, alpha = alpha, sigma = sigma)
    num.vec[i, 4] <- as.numeric(EM.case.1.sigma(alpha = alpha, data = cc, sigma = MME.case1.sigma(alpha = alpha, data = cc))$par)
    num.vec[i, 5] <- (num.vec[i, 4] - num.vec[i, 3])/num.vec[i, 3]
  }
  return(data.frame(num.vec))
}

l <- rbind(sim.MLE.case1.sigma(alpha = 0.7, sigma = 0.5, num = 50), sim.MLE.case1.sigma(alpha = 0.7, sigma = 0.5, num = 150), sim.MLE.case1.sigma(alpha = 0.7, sigma = 0.5, num = 300),
           sim.MLE.case1.sigma(alpha = 1, sigma = 1, num = 50), sim.MLE.case1.sigma(alpha = 1, sigma = 1, num = 150), sim.MLE.case1.sigma(alpha = 1, sigma = 1, num = 300),
           sim.MLE.case1.sigma(alpha = 2, sigma = 5, num = 50), sim.MLE.case1.sigma(alpha = 2, sigma = 5, num = 150), sim.MLE.case1.sigma(alpha = 2, sigma = 5, num = 300),
           sim.MLE.case1.sigma(alpha = 1, sigma = 0.5, num = 50), sim.MLE.case1.sigma(alpha = 2, sigma = 0.5, num = 50), sim.MLE.case1.sigma(alpha = 1, sigma = 0.5, num = 150),
           sim.MLE.case1.sigma(alpha = 2, sigma = 0.5, num = 150), sim.MLE.case1.sigma(alpha = 1, sigma = 0.5, num = 300), sim.MLE.case1.sigma(alpha = 2, sigma = 0.5, num = 300),
           sim.MLE.case1.sigma(alpha = 0.7, sigma = 1, num = 50), sim.MLE.case1.sigma(alpha = 2, sigma = 1, num = 50), sim.MLE.case1.sigma(alpha = 0.7, sigma = 1, num = 150),
           sim.MLE.case1.sigma(alpha = 2, sigma = 1, num = 150), sim.MLE.case1.sigma(alpha = 0.7, sigma = 1, num = 300), sim.MLE.case1.sigma(alpha = 2, sigma = 1, num = 300),
           sim.MLE.case1.sigma(alpha = 0.7, sigma = 5, num = 50), sim.MLE.case1.sigma(alpha = 1, sigma = 5, num = 50), sim.MLE.case1.sigma(alpha = 0.7, sigma = 5, num = 150),
           sim.MLE.case1.sigma(alpha = 1, sigma = 5, num = 150), sim.MLE.case1.sigma(alpha = 0.7, sigma = 5, num = 300), sim.MLE.case1.sigma(alpha = 1, sigma = 5, num = 300))

load(file = "C:/Users/Esther/Desktop/Normal Pareto/MLE.case1.sigma.1000.simulations1.RData")
load(file = "C:/Users/Esther/Desktop/Normal Pareto/MLE.case1.sigma.1000.simulations2.RData")
load(file = "C:/Users/Esther/Desktop/Normal Pareto/MLE.case1.sigma.1000.simulations3.RData")

save(l, file = "MLE.case1.sigma.1000.simulations.RData")
l1 <- l
l <- rbind(l1, l2, l3)

library(ggplot2)
# Relative error graphs
gh <- ggplot(l, aes(x = RelativeError)) + geom_histogram(aes(y = ..density..)) + facet_grid(sigma ~ Sample + alpha, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = Estimate)) + geom_boxplot() + geom_hline(aes(yintercept = sigma), color = "red") +
  facet_wrap(sigma ~ alpha, scales = "free", labeller = label_both) + labs(x = "Sample size") + theme_classic()
th

# Generating table
tab1 <- l[which(l$Sample == 300 & l$sigma == 5 & l$alpha == 2), ]
(esti <- round(mean(tab1$Estimate), 4))
(MSE <- round(mean( (tab1$sigma - tab1$Estimate)^2 ), 4 ))

# Case 2 alpha unknown, sigma known
EM.case.2.alpha <- function(data, tol = 1e-2, maxiter = 500, sigma = 1, alpha = 1, verb = FALSE){
  #------------------------- First space (checking input errors) ----------------------------------------#
  if(!is.numeric(sigma) | !is.numeric(tol) | !is.numeric(data)) stop(
    "arguments 'y', 'tol', 'maxiter', 'sigma' must be numeric")
  if(sigma <= 0 | alpha <= 0) stop("alpha and sigma must be positive")
  #######################################################################################################
  #---------------------------- Second space (necessary functions) --------------------------------------#
  log_like <- function(iter.alpha, iter.sigma = sigma){
    sum(log(NP.pdf(data, alpha = iter.alpha, sigma = iter.sigma)))}

  # function to compute all expectations
  all.expectations <- function(iter.sigma = sigma, iter.alpha){
    a_k <- array(NA, dim = length(data)); c_k <- array(NA, dim = length(data))
    for(y_i in data){
      fun.1 <- function(t) (sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.2 <- function(t) t*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.4 <- function(t) log(t)*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))

      dens.y <- adaptIntegrate(fun.1, lowerLimit = 0, upperLimit = Inf)$integral
      a.exp <- adaptIntegrate(fun.2, lowerLimit = 0, upperLimit = Inf)$integral/dens.y
      c.exp <- adaptIntegrate(fun.4, lowerLimit = 0, upperLimit = Inf)$integral/dens.y
      pos <- match(y_i, data)
      a_k[pos] <- a.exp; c_k[pos] <- c.exp
    }
    dat <- data.frame(a_k, c_k)
    return(dat)}
  #####################################################
  #### E step
  expect <- all.expectations(iter.alpha = alpha)
  a_old <- expect$a_k; c_old <- expect$c_k
  ll_old <- log_like(iter.alpha = alpha)
  k = 0
  alpha_old <- alpha
  output <- c(k, alpha_old, ll_old)
  diff <- tol + 1

  while((diff > tol) & (k < maxiter)){
    #### M step
    alpha <- suppressWarnings(stats::nlm(function(x) length(data)*(log(x)/x + lgamma(1/x)) - sum(c_old - a_old)/x , p = alpha)$estimate)
    expect <- all.expectations(iter.alpha = alpha)
    a_old <- expect$a_k; c_old <- expect$c_k
    ll_new <- log_like(iter.alpha = alpha)
    diff <- ll_new - ll_old
    ll_old <- ll_new
    k <- k + 1
    output <- rbind(output, c(k, alpha, ll_new))
    if(verb){
      cat("iteration =", k, " log.lik.diff =", diff, " log.lik =",
          ll_new, "\n")}

    if(k == maxiter){
      cat("Warning! Convergence not achieved!", "\n")
    }
    output <- data.frame(output)
    colnames(output) <- c("iteration","alpha","log-lik")
    par <- data.frame(t(c(alpha)))
    colnames(par) <- c("alpha")
    result <- list(par=par, log.like = ll_new, iterations=k, output=output)
  }
  return(result)
}

# Iteration plots
rt1 <- rNPare(n = 1000, alpha = 0.7, sigma = 1)
rt2 <- rNPare(n = 1000, alpha = 1, sigma = 1)
rt3 <- rNPare(n = 1000, alpha = 2, sigma = 1)

l1 <- EM.case.2.alpha(data = rt1, alpha = 1.5, sigma = 1)
l2 <- EM.case.2.alpha(data = rt1, alpha = MME.case2.alpha(sigma = 1, data = rt1), sigma = 1)
l3 <- EM.case.2.alpha(data = rt1, alpha = 0.3, sigma = 1 )

plot(l1$output$iteration, l1$output$alpha, ylim = c(0, max(l1$output$alpha,l2$output$alpha,l3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(l1$output$iteration, l2$output$iteration, l3$output$iteration)))
points(l2$output$iteration, l2$output$alpha, type = "o", pch = 19, col = "blue")
points(l3$output$iteration, l3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 0.7, col = "red", lty = 2)
legend(15, 1.2, legend = c("Intial values", expression(paste(alpha, " = 1.0559 (MME)" )),
                          expression(paste(alpha, " = 1.5" )), expression(paste(alpha, " = 0.3"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

m1 <- EM.case.2.alpha(data = rt2, alpha = 0.5, sigma = 1)
m2 <- EM.case.2.alpha(data = rt2, alpha = MME.case2.alpha(sigma = 1, data = rt2), sigma = 1)
m3 <- EM.case.2.alpha(data = rt2, alpha = 1.5, sigma = 1)

plot(m1$output$iteration, m1$output$alpha, ylim = c(0, max(m1$output$alpha,m2$output$alpha,m3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(m1$output$iteration, m2$output$iteration, m3$output$iteration)))
points(m2$output$iteration, m2$output$alpha, type = "o", pch = 19, col = "blue")
points(m3$output$iteration, m3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 1, col = "red", lty = 2)
legend(8, 0.5, legend = c("Intial values", expression(paste(alpha, " = 0.8969 (MME)" )),
                          expression(paste(alpha, " = 1.5" )), expression(paste(alpha, " = 0.5"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

n1 <- EM.case.2.alpha(data = rt3, alpha = 0.7, sigma = 1)
n2 <- EM.case.2.alpha(data = rt3, alpha = MME.case2.alpha(sigma = 1, data = rt3), sigma = 1)
n3 <- EM.case.2.alpha(data = rt3, alpha = 5, sigma = 1)

plot(n1$output$iteration, n1$output$alpha, ylim = c(0, max(n1$output$alpha,n2$output$alpha,n3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(n1$output$iteration, n2$output$iteration, n3$output$iteration)))
points(n2$output$iteration, n2$output$alpha, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 2, col = "red", lty = 2)
legend(5, 4, legend = c("Intial values", expression(paste(alpha, " = 1.7960 (MME)")),
                        expression(paste(alpha, " = 5" )), expression(paste(alpha, " = 0.7"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

first <- list(rt1,l1,l2,l3)
second <- list(rt2,m1,m2,m3)
third <-list(rt3,n1,n2,n3)

save(first, file = "EM.data.1000.alpha.unknown.0.7.sigma.known.1.RData")
save(second, file = "EM.data.1000.alpha.unknown.1.sigma.known.1.RData")
save(third, file = "EM.data.1000.alpha.unknown.2.sigma.known.1.RData")

sim.MLE.case2.alpha <- function(k = 1000, alpha = 0.5, sigma = 1, num = 10){
  num.vec <- matrix(NA, nrow = k, ncol = 5)
  colnames(num.vec) <- c("Sample", "alpha", "sigma", "Estimate", "RelativeError")
  num.vec[ , 1] <- rep(num, k)
  num.vec[ , 2] <- rep(alpha, k)
  num.vec[ , 3] <- rep(sigma, k)

  # Generate independent Y's
  for(i in 1:k){
    cc <- rNPare(n = num, alpha = alpha, sigma = sigma)
    num.vec[i, 4] <- as.numeric(EM.case.2.alpha(alpha = MME.case2.alpha(sigma = sigma, data = cc), data = cc, sigma = sigma)$par)
    num.vec[i, 5] <- (num.vec[i, 4] - num.vec[i, 2])/num.vec[i, 2]
  }
  return(data.frame(num.vec))
}

l <- rbind(sim.MLE.case2.alpha(alpha = 0.7, sigma = 0.5, num = 50), sim.MLE.case2.alpha(alpha = 0.7, sigma = 0.5, num = 150), sim.MLE.case2.alpha(alpha = 0.7, sigma = 0.5, num = 300),
           sim.MLE.case2.alpha(alpha = 1, sigma = 1, num = 50), sim.MLE.case2.alpha(alpha = 1, sigma = 1, num = 150), sim.MLE.case2.alpha(alpha = 1, sigma = 1, num = 300),
           sim.MLE.case2.alpha(alpha = 2, sigma = 5, num = 50), sim.MLE.case2.alpha(alpha = 2, sigma = 5, num = 150), sim.MLE.case2.alpha(alpha = 2, sigma = 5, num = 300),
           sim.MLE.case2.alpha(alpha = 1, sigma = 0.5, num = 50), sim.MLE.case2.alpha(alpha = 2, sigma = 0.5, num = 50), sim.MLE.case2.alpha(alpha = 1, sigma = 0.5, num = 150),
           sim.MLE.case2.alpha(alpha = 2, sigma = 0.5, num = 150), sim.MLE.case2.alpha(alpha = 1, sigma = 0.5, num = 300), sim.MLE.case2.alpha(alpha = 2, sigma = 0.5, num = 300),
           sim.MLE.case2.alpha(alpha = 0.7, sigma = 1, num = 50), sim.MLE.case2.alpha(alpha = 2, sigma = 1, num = 50), sim.MLE.case2.alpha(alpha = 0.7, sigma = 1, num = 150),
           sim.MLE.case2.alpha(alpha = 2, sigma = 1, num = 150), sim.MLE.case2.alpha(alpha = 0.7, sigma = 1, num = 300), sim.MLE.case2.alpha(alpha = 2, sigma = 1, num = 300),
           sim.MLE.case2.alpha(alpha = 0.7, sigma = 5, num = 50), sim.MLE.case2.alpha(alpha = 1, sigma = 5, num = 50), sim.MLE.case2.alpha(alpha = 0.7, sigma = 5, num = 150),
           sim.MLE.case2.alpha(alpha = 1, sigma = 5, num = 150), sim.MLE.case2.alpha(alpha = 0.7, sigma = 5, num = 300), sim.MLE.case2.alpha(alpha = 1, sigma = 5, num = 300))

save(l, file = "MLE.case2.alpha.1000.simulations.RData")

library(ggplot2)
# Relative error graphs
gh <- ggplot(l, aes(x = RelativeError)) + geom_histogram(aes(y = ..density..)) + facet_grid(sigma ~ Sample + alpha, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = Estimate)) + geom_boxplot() + geom_hline(aes(yintercept = alpha), color = "red") +
  facet_wrap(sigma ~ alpha, scales = "free", labeller = label_both) + labs(x = "Sample size") + theme_classic()
th

# Generating table
tab1 <- l[which(l$Sample == 50 & l$sigma == 0.5 & l$alpha == 0.7), ]
(esti <- round(mean(tab1$Estimate), 4))
(MSE <- round(mean( (tab1$sigma - tab1$Estimate)^2 ), 4 ))

tab1 <- l[which(l$Sample == 300 & l$sigma == 5 & l$alpha == 2), ]
(esti <- round(mean(tab1$Estimate), 4 ))
(MSE <- round(mean( (tab1$sigma - tab1$Estimate)^2 ), 4 ))

# Case 3 alpha and sigma unknown
EM.case.3.alpha.sigma <- function(data, tol = 1e-2, maxiter = 500, sigma = 1, alpha = 1, verb = FALSE){
  #------------------------- First space (checking input errors) ----------------------------------------#
  if(!is.numeric(sigma) | !is.numeric(alpha) | !is.numeric(tol) | !is.numeric(data)) stop(
    "arguments 'y', 'tol', 'maxiter', 'sigma', 'alpha' must be numeric")
  if(sigma <= 0 | alpha <= 0) stop("alpha and sigma must be positive")
  #######################################################################################################
  #---------------------------- Second space (necessary functions) --------------------------------------#
  log_like <- function(iter.alpha, iter.sigma){
    sum(log(NP.pdf(data, alpha = iter.alpha, sigma = iter.sigma)))}

  # function to compute all expectations
  all.expectations <- function(iter.sigma, iter.alpha){
    a_k <- array(NA, dim = length(data)); b_k <- array(NA, dim = length(data)); c_k <- array(NA, dim = length(data))
    for(y_i in data){
      fun.1 <- function(t) (sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.2 <- function(t) t*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.3 <- function(t) sqrt(t)*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.4 <- function(t) log(t)*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))

      dens.y <- adaptIntegrate(fun.1, lowerLimit = 0, upperLimit = Inf)$integral
      a.exp <- adaptIntegrate(fun.2, lowerLimit = 0, upperLimit = Inf)$integral/dens.y
      b.exp <- adaptIntegrate(fun.3, lowerLimit = 0, upperLimit = Inf)$integral/dens.y
      c.exp <- adaptIntegrate(fun.4, lowerLimit = 0, upperLimit = Inf)$integral/dens.y
      pos <- match(y_i, data)
      a_k[pos] <- a.exp; b_k[pos] <- b.exp; c_k[pos] <- c.exp
    }
    dat <- data.frame(a_k, b_k, c_k)
    return(dat)}
  #####################################################
  #### E step
  expect <- all.expectations(iter.alpha = alpha, iter.sigma = sigma)
  a_old <- expect$a_k; b_old <- expect$b_k; c_old <- expect$c_k
  ll_old <- log_like(iter.alpha = alpha, iter.sigma = sigma)
  k = 0
  alpha_old <- alpha; sigma_old <- sigma
  output <- c(k, alpha_old, sigma_old, ll_old)
  diff <- tol + 1

  while((diff > tol) & (k < maxiter)){
    #### M step
    alpha <- suppressWarnings(stats::nlm(function(x) length(data)*(log(x)/x + lgamma(1/x)) - sum(c_old - a_old)/x , p = alpha)$estimate)
    sigma <- sqrt(2)*mean(b_old*abs(data))
    expect <- all.expectations(iter.alpha = alpha, iter.sigma = sigma)
    a_old <- expect$a_k; b_old <- expect$b_k; c_old <- expect$c_k
    ll_new <- log_like(iter.alpha = alpha, iter.sigma = sigma)
    diff <- ll_new - ll_old
    ll_old <- ll_new
    k <- k + 1
    output <- rbind(output, c(k, alpha, sigma, ll_new))
    if(verb){
      cat("iteration =", k, " log.lik.diff =", diff, " log.lik =",
          ll_new, "\n")}

    if(k == maxiter){
      cat("Warning! Convergence not achieved!", "\n")
    }
    output <- data.frame(output)
    colnames(output) <- c("iteration","alpha", "sigma","log-lik")
    par <- data.frame(t(c(alpha, sigma)))
    colnames(par) <- c("alpha", "sigma")
    result <- list(par=par, log.like = ll_new, iterations=k, output=output)
  }
  return(result)
}

library(rootSolve); library(cubature)
# MME
MME.case3.alpha.sigma <- function(data){
  R <- mean(log(abs(data))) - 0.5*(log(2) + digamma(1/2) + digamma(1)) - 2*log(gamma(3/4)*gamma(1/4)/(sqrt(pi)*(2^0.25)*mean(abs(data)^(-0.5))))

  fin <- function(alpha){
    h <- 0.5*(log(1/alpha) - digamma(1/alpha)) + 2*log((alpha^0.25)*gamma(1/alpha + 0.25)/gamma(1/alpha)) - R
    return(h)
  }
  alpha <- uniroot(fin, lower = 0.01, upper = 100, extendInt = "yes")$root
  sigma <- ( (alpha^0.25 * gamma(1/alpha + 0.25)*gamma(3/4)*gamma(1/4)  )/(mean(abs(data)^(-0.5))*gamma(1/2)*(2^0.25)*gamma(1/alpha)))^2
  return(c(alpha, sigma))
}

# Iteration plots
rt1 <- rNPare(n = 1000, alpha = 0.7, sigma = 0.5)
rt2 <- rNPare(n = 1000, alpha = 0.7, sigma = 1)
rt3 <- rNPare(n = 1000, alpha = 0.7, sigma = 5)
rt4 <- rNPare(n = 1000, alpha = 1, sigma = 0.5)
rt5 <- rNPare(n = 1000, alpha = 1, sigma = 1)
rt6 <- rNPare(n = 1000, alpha = 1, sigma = 5)
rt7 <- rNPare(n = 1000, alpha = 2, sigma = 0.5)
rt8 <- rNPare(n = 1000, alpha = 2, sigma = 1)
rt9 <- rNPare(n = 1000, alpha = 2, sigma = 5)

l1 <- EM.case.3.alpha.sigma(data = rt1, alpha =  1.5, sigma = 1)
l2 <- EM.case.3.alpha.sigma(data = rt1, alpha = MME.case3.alpha.sigma(data = rt1)[1], sigma = MME.case3.alpha.sigma(data = rt1)[2])
l3 <- EM.case.3.alpha.sigma(data = rt1, alpha = 0.3, sigma = 0.2)

plot(l1$output$iteration, l1$output$alpha, ylim = c(0, max(l1$output$alpha,l2$output$alpha,l3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(l1$output$iteration, l2$output$iteration, l3$output$iteration)))
points(l2$output$iteration, l2$output$alpha, type = "o", pch = 19, col = "blue")
points(l3$output$iteration, l3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 0.7, col = "red", lty = 2)
legend(15, 1.45, legend = c("Intial values", expression(paste(alpha, " = 0.3014, ", sigma, " = 0.6055 (MME)")),
                           expression(paste(alpha, " = 1.5, ", sigma, " = 1" )), expression(paste(alpha, " = 0.3, ", sigma, " = 0.2"))),
       col = c("", "blue", "black", "green"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

plot(l1$output$iteration, l1$output$sigma, ylim = c(0, max(l1$output$sigma,l2$output$sigma,l3$output$sigma)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(sigma, " values")), xlim = c(0, max(l1$output$iteration, l2$output$iteration, l3$output$iteration)))
points(l2$output$iteration, l2$output$sigma, type = "o", pch = 19, col = "blue")
points(l3$output$iteration, l3$output$sigma, type = "o", col = "green", pch = 19)
abline(h = 0.5, col = "red", lty = 2)
legend(15, 0.4, legend = c("Intial values", expression(paste(alpha, " = 0.3014; ", sigma, " = 0.6055 (MME)")),
                           expression(paste(alpha, " = 1.5, ", sigma, " = 1" )), expression(paste(alpha, " = 0.3, ", sigma, " = 0.2"))),
       col = c("", "blue", "black", "green"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

m1 <- EM.case.3.alpha.sigma(data = rt2, alpha = 1.5, sigma = 3)
m2 <- EM.case.3.alpha.sigma(data = rt2, alpha = MME.case3.alpha.sigma(data = rt2)[1], sigma = MME.case3.alpha.sigma(data = rt2)[2])
m3 <- EM.case.3.alpha.sigma(data = rt2, alpha = 0.3, sigma = 0.5)

plot(m1$output$iteration, m1$output$alpha, ylim = c(0, max(m1$output$alpha,m2$output$alpha,m3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(m1$output$iteration, m2$output$iteration, m3$output$iteration)))
points(m2$output$iteration, m2$output$alpha, type = "o", pch = 19, col = "blue")
points(m3$output$iteration, m3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 0.7, col = "red", lty = 2)
legend(8, 0.5, legend = c("Intial values", expression(paste(alpha, " = 0.8969 (MME)" )),
                          expression(paste(alpha, " = 1.5" )), expression(paste(alpha, " = 0.5"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

n1 <- EM.case.2.alpha(data = rt3, alpha = 0.7, sigma = 1)
n2 <- EM.case.2.alpha(data = rt3, alpha = MME.case2.alpha(sigma = 1, data = rt3), sigma = 1)
n3 <- EM.case.2.alpha(data = rt3, alpha = 5, sigma = 1)

plot(n1$output$iteration, n1$output$alpha, ylim = c(0, max(n1$output$alpha,n2$output$alpha,n3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(n1$output$iteration, n2$output$iteration, n3$output$iteration)))
points(n2$output$iteration, n2$output$alpha, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 2, col = "red", lty = 2)
legend(5, 4, legend = c("Intial values", expression(paste(alpha, " = 1.7960 (MME)")),
                        expression(paste(alpha, " = 5" )), expression(paste(alpha, " = 0.7"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

o1 <- EM.case.2.alpha(data = rt3, alpha = 0.7, sigma = 1)
o2 <- EM.case.2.alpha(data = rt3, alpha = MME.case2.alpha(sigma = 1, data = rt3), sigma = 1)
o3 <- EM.case.2.alpha(data = rt3, alpha = 5, sigma = 1)

plot(n1$output$iteration, n1$output$alpha, ylim = c(0, max(n1$output$alpha,n2$output$alpha,n3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(n1$output$iteration, n2$output$iteration, n3$output$iteration)))
points(n2$output$iteration, n2$output$alpha, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 2, col = "red", lty = 2)
legend(5, 4, legend = c("Intial values", expression(paste(alpha, " = 1.7960 (MME)")),
                        expression(paste(alpha, " = 5" )), expression(paste(alpha, " = 0.7"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

p1 <- EM.case.2.alpha(data = rt3, alpha = 0.7, sigma = 1)
p2 <- EM.case.2.alpha(data = rt3, alpha = MME.case2.alpha(sigma = 1, data = rt3), sigma = 1)
p3 <- EM.case.2.alpha(data = rt3, alpha = 5, sigma = 1)

plot(n1$output$iteration, n1$output$alpha, ylim = c(0, max(n1$output$alpha,n2$output$alpha,n3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(n1$output$iteration, n2$output$iteration, n3$output$iteration)))
points(n2$output$iteration, n2$output$alpha, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 2, col = "red", lty = 2)
legend(5, 4, legend = c("Intial values", expression(paste(alpha, " = 1.7960 (MME)")),
                        expression(paste(alpha, " = 5" )), expression(paste(alpha, " = 0.7"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

q1 <- EM.case.2.alpha(data = rt3, alpha = 0.7, sigma = 1)
q2 <- EM.case.2.alpha(data = rt3, alpha = MME.case2.alpha(sigma = 1, data = rt3), sigma = 1)
q3 <- EM.case.2.alpha(data = rt3, alpha = 5, sigma = 1)

plot(n1$output$iteration, n1$output$alpha, ylim = c(0, max(n1$output$alpha,n2$output$alpha,n3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(n1$output$iteration, n2$output$iteration, n3$output$iteration)))
points(n2$output$iteration, n2$output$alpha, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 2, col = "red", lty = 2)
legend(5, 4, legend = c("Intial values", expression(paste(alpha, " = 1.7960 (MME)")),
                        expression(paste(alpha, " = 5" )), expression(paste(alpha, " = 0.7"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

r1 <- EM.case.2.alpha(data = rt3, alpha = 0.7, sigma = 1)
r2 <- EM.case.2.alpha(data = rt3, alpha = MME.case2.alpha(sigma = 1, data = rt3), sigma = 1)
r3 <- EM.case.2.alpha(data = rt3, alpha = 5, sigma = 1)

plot(n1$output$iteration, n1$output$alpha, ylim = c(0, max(n1$output$alpha,n2$output$alpha,n3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(n1$output$iteration, n2$output$iteration, n3$output$iteration)))
points(n2$output$iteration, n2$output$alpha, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 2, col = "red", lty = 2)
legend(5, 4, legend = c("Intial values", expression(paste(alpha, " = 1.7960 (MME)")),
                        expression(paste(alpha, " = 5" )), expression(paste(alpha, " = 0.7"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

s1 <- EM.case.2.alpha(data = rt3, alpha = 0.7, sigma = 1)
s2 <- EM.case.2.alpha(data = rt3, alpha = MME.case2.alpha(sigma = 1, data = rt3), sigma = 1)
s3 <- EM.case.2.alpha(data = rt3, alpha = 5, sigma = 1)

plot(n1$output$iteration, n1$output$alpha, ylim = c(0, max(n1$output$alpha,n2$output$alpha,n3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(n1$output$iteration, n2$output$iteration, n3$output$iteration)))
points(n2$output$iteration, n2$output$alpha, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 2, col = "red", lty = 2)
legend(5, 4, legend = c("Intial values", expression(paste(alpha, " = 1.7960 (MME)")),
                        expression(paste(alpha, " = 5" )), expression(paste(alpha, " = 0.7"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)

t1 <- EM.case.2.alpha(data = rt3, alpha = 0.7, sigma = 1)
t2 <- EM.case.2.alpha(data = rt3, alpha = MME.case2.alpha(sigma = 1, data = rt3), sigma = 1)
t3 <- EM.case.2.alpha(data = rt3, alpha = 5, sigma = 1)

plot(n1$output$iteration, n1$output$alpha, ylim = c(0, max(n1$output$alpha,n2$output$alpha,n3$output$alpha)), type = "o", pch = 19,
     xlab = "Iteration", ylab = expression(paste(alpha, " values")), xlim = c(0, max(n1$output$iteration, n2$output$iteration, n3$output$iteration)))
points(n2$output$iteration, n2$output$alpha, type = "o", pch = 19, col = "blue")
points(n3$output$iteration, n3$output$alpha, type = "o", col = "green", pch = 19)
abline(h = 2, col = "red", lty = 2)
legend(5, 4, legend = c("Intial values", expression(paste(alpha, " = 1.7960 (MME)")),
                        expression(paste(alpha, " = 5" )), expression(paste(alpha, " = 0.7"))),
       col = c("", "blue", "green", "black"), lty = c(NA, 1, 1,1), pch = c(NA, 19, 19, 19), bty = "n",
       cex = 1.2, seg.len = 1, x.intersp = 0.1, y.intersp = 0.8)


first <- list(rt1,l1,l2,l3)
second <- list(rt2,m1,m2,m3)
third <-list(rt3,n1,n2,n3)

save(first, file = "EM.data.1000.alpha.unknown.0.7.sigma.known.1.RData")
save(second, file = "EM.data.1000.alpha.unknown.1.sigma.known.1.RData")
save(third, file = "EM.data.1000.alpha.unknown.2.sigma.known.1.RData")

sim.MLE.case2.alpha <- function(k = 1000, alpha = 0.5, sigma = 1, num = 10){
  num.vec <- matrix(NA, nrow = k, ncol = 5)
  colnames(num.vec) <- c("Sample", "alpha", "sigma", "Estimate", "RelativeError")
  num.vec[ , 1] <- rep(num, k)
  num.vec[ , 2] <- rep(alpha, k)
  num.vec[ , 3] <- rep(sigma, k)

  # Generate independent Y's
  for(i in 1:k){
    cc <- rNPare(n = num, alpha = alpha, sigma = sigma)
    num.vec[i, 4] <- as.numeric(EM.case.2.alpha(alpha = MME.case2.alpha(sigma = sigma, data = cc), data = cc, sigma = sigma)$par)
    num.vec[i, 5] <- (num.vec[i, 4] - num.vec[i, 2])/num.vec[i, 2]
  }
  return(data.frame(num.vec))
}

l <- rbind(sim.MLE.case2.alpha(alpha = 0.7, sigma = 0.5, num = 50), sim.MLE.case2.alpha(alpha = 0.7, sigma = 0.5, num = 150), sim.MLE.case2.alpha(alpha = 0.7, sigma = 0.5, num = 300),
           sim.MLE.case2.alpha(alpha = 1, sigma = 1, num = 50), sim.MLE.case2.alpha(alpha = 1, sigma = 1, num = 150), sim.MLE.case2.alpha(alpha = 1, sigma = 1, num = 300),
           sim.MLE.case2.alpha(alpha = 2, sigma = 5, num = 50), sim.MLE.case2.alpha(alpha = 2, sigma = 5, num = 150), sim.MLE.case2.alpha(alpha = 2, sigma = 5, num = 300),
           sim.MLE.case2.alpha(alpha = 1, sigma = 0.5, num = 50), sim.MLE.case2.alpha(alpha = 2, sigma = 0.5, num = 50), sim.MLE.case2.alpha(alpha = 1, sigma = 0.5, num = 150),
           sim.MLE.case2.alpha(alpha = 2, sigma = 0.5, num = 150), sim.MLE.case2.alpha(alpha = 1, sigma = 0.5, num = 300), sim.MLE.case2.alpha(alpha = 2, sigma = 0.5, num = 300),
           sim.MLE.case2.alpha(alpha = 0.7, sigma = 1, num = 50), sim.MLE.case2.alpha(alpha = 2, sigma = 1, num = 50), sim.MLE.case2.alpha(alpha = 0.7, sigma = 1, num = 150),
           sim.MLE.case2.alpha(alpha = 2, sigma = 1, num = 150), sim.MLE.case2.alpha(alpha = 0.7, sigma = 1, num = 300), sim.MLE.case2.alpha(alpha = 2, sigma = 1, num = 300),
           sim.MLE.case2.alpha(alpha = 0.7, sigma = 5, num = 50), sim.MLE.case2.alpha(alpha = 1, sigma = 5, num = 50), sim.MLE.case2.alpha(alpha = 0.7, sigma = 5, num = 150),
           sim.MLE.case2.alpha(alpha = 1, sigma = 5, num = 150), sim.MLE.case2.alpha(alpha = 0.7, sigma = 5, num = 300), sim.MLE.case2.alpha(alpha = 1, sigma = 5, num = 300))

save(l, file = "MLE.case2.alpha.1000.simulations.RData")

library(ggplot2)
# Relative error graphs
gh <- ggplot(l, aes(x = RelativeError)) + geom_histogram(aes(y = ..density..)) + facet_grid(sigma ~ Sample + alpha, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = Estimate)) + geom_boxplot() + geom_hline(aes(yintercept = alpha), color = "red") +
  facet_wrap(sigma ~ alpha, scales = "free", labeller = label_both) + labs(x = "Sample size") + theme_classic()
th

# Generating table
tab1 <- l[which(l$Sample == 50 & l$sigma == 0.5 & l$alpha == 0.7), ]
(esti <- round(mean(tab1$Estimate), 4))
(MSE <- round(mean( (tab1$sigma - tab1$Estimate)^2 ), 4 ))

tab1 <- l[which(l$Sample == 300 & l$sigma == 5 & l$alpha == 2), ]
(esti <- round(mean(tab1$Estimate), 4 ))
(MSE <- round(mean( (tab1$sigma - tab1$Estimate)^2 ), 4 ))

# This is for Case 2
load(file = "MLE.case2.alpha.1000.simulations.RData")
tab1 <- l[which(l$Sample == 300 & l$sigma == 5 & l$alpha == 2), ]
(esti <- round(mean(tab1$Estimate), 4 ))
(MSE <- round(mean( (tab1$alpha - tab1$Estimate)^2 ), 4 ))

# Relative error graphs
gh <- ggplot(l, aes(x = RelativeError)) + geom_histogram(aes(y = ..density..)) + facet_grid( alpha ~ sigma + Sample, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh


# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = Estimate)) + geom_boxplot() + geom_hline(aes(yintercept = alpha), color = "red") +
  facet_wrap(alpha ~ sigma, scales = "free", labeller = label_both) + labs(x = "Sample size") + theme_classic()
th



# This is for case 3
load(file = "MLE.case3.alpha.sigma.1.simulations.RData")
load(file = "MLE.case3.alpha.sigma.4.simulations.RData")
load(file = "MLE.case3.alpha.sigma.5.simulations.RData")
load(file = "MLE.case3.alpha.sigma.7.simulations.RData")
load(file = "MLE.case3.alpha.sigma.8.simulations.RData")
load(file = "MLE.case3.alpha.sigma.10.simulations.RData")
load(file = "MLE.case3.alpha.sigma.11.simulations.RData")
load(file = "MLE.case3.alpha.sigma.13.simulations.RData")
load(file = "MLE.case3.alpha.sigma.14.simulations.RData")
load(file = "MLE.case3.alpha.sigma.16.simulations.RData")
load(file = "MLE.case3.alpha.sigma.17.simulations.RData")
load(file = "MLE.case3.alpha.sigma.19.simulations.RData")
load(file = "MLE.case3.alpha.sigma.20.simulations.RData")
load(file = "MLE.case3.alpha.sigma.22.simulations.RData")
load(file = "MLE.case3.alpha.sigma.23.simulations.RData")
load(file = "MLE.case3.alpha.sigma.25.simulations.RData")
load(file = "MLE.case3.alpha.sigma.26.simulations.RData")

l <- rbind(l1[complete.cases(l1), ], l4[complete.cases(l4), ], l5[complete.cases(l5), ], l7[complete.cases(l7), ], l8[complete.cases(l8), ], l10[complete.cases(l10), ], l11[complete.cases(l11), ],
           l13[complete.cases(l13), ], l14[complete.cases(l14), ], l16[complete.cases(l16), ], l17[complete.cases(l17), ], l19[complete.cases(l19), ], l20[complete.cases(l20), ], l22[complete.cases(l22), ],
           l23[complete.cases(l23), ], l25[complete.cases(l25), ], l26[complete.cases(l26), ])

# Plots for alpha
# Relative error graphs
gh <- ggplot(l, aes(x = RelativeErrorAlpha)) + geom_histogram(aes(y = ..density..)) + facet_grid( alpha ~ sigma + Sample, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

gh <- ggplot(l, aes(x = RelativeErrorAlpha)) + geom_histogram(aes(y = ..density..)) + facet_grid( alpha ~ sigma + Sample, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = EstimateAlpha)) + geom_boxplot() + geom_hline(aes(yintercept = alpha), color = "red") +
  facet_wrap(alpha ~ sigma, scales = "free", labeller = label_both) + labs(x = "Sample size", y = expression(paste("Estimate ", alpha))) + theme_classic()
th

# Plots for sigma
gh <- ggplot(l, aes(x = RelativeErrorSigma)) + geom_histogram(aes(y = ..density..)) + facet_grid(alpha ~ sigma + Sample, scales = "free", labeller = label_both) + theme_classic()
gh <- gh + labs(x = "Relative Error")
gh

# Boxplots
th <- ggplot(l, aes(x = as.factor(Sample), y = EstimateSigma)) + geom_boxplot() + geom_hline(aes(yintercept = sigma), color = "red") +
  facet_wrap(alpha ~ sigma, scales = "free", labeller = label_both) + labs(x = "Sample size", y = expression(paste("Estimate ", sigma))) + theme_classic()
th

# Real Data fit
EM.case.3.alpha.sigma <- function(data, tol = 1e-2, maxiter = 500, sigma = 1, alpha = 1, verb = FALSE){
  #------------------------- First space (checking input errors) ----------------------------------------#
  if(!is.numeric(sigma) | !is.numeric(alpha) | !is.numeric(tol) | !is.numeric(data)) stop(
    "arguments 'y', 'tol', 'maxiter', 'sigma', 'alpha' must be numeric")
  if(sigma <= 0 | alpha <= 0) stop("alpha and sigma must be positive")
  #######################################################################################################
  #---------------------------- Second space (necessary functions) --------------------------------------#
  log_like <- function(iter.alpha, iter.sigma){
    sum(log(NP.pdf(data, alpha = iter.alpha, sigma = iter.sigma)))}

  # function to compute all expectations
  all.expectations <- function(iter.sigma, iter.alpha){
    a_k <- array(NA, dim = length(data)); b_k <- array(NA, dim = length(data)); c_k <- array(NA, dim = length(data))
    for(y_i in data){
      fun.1 <- function(t) (sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.2 <- function(t) t*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.3 <- function(t) sqrt(t)*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))
      fun.4 <- function(t) log(t)*(sqrt(t/2)/iter.sigma)*exp(-sqrt(2*t)*abs(y_i)/iter.sigma)*(t^(1/iter.alpha - 1)*exp(-t/iter.alpha))/((iter.alpha)^(1/iter.alpha)*gamma(1/iter.alpha))

      dens.y <- adaptIntegrate(fun.1, lowerLimit = 0, upperLimit = Inf)$integral
      a.exp <- adaptIntegrate(fun.2, lowerLimit = 0, upperLimit = Inf)$integral/dens.y
      b.exp <- adaptIntegrate(fun.3, lowerLimit = 0, upperLimit = Inf)$integral/dens.y
      c.exp <- adaptIntegrate(fun.4, lowerLimit = 0, upperLimit = Inf)$integral/dens.y
      pos <- match(y_i, data)
      a_k[pos] <- a.exp; b_k[pos] <- b.exp; c_k[pos] <- c.exp
    }
    dat <- data.frame(a_k, b_k, c_k)
    return(dat)}
  #####################################################
  #### E step
  expect <- all.expectations(iter.alpha = alpha, iter.sigma = sigma)
  a_old <- expect$a_k; b_old <- expect$b_k; c_old <- expect$c_k
  ll_old <- log_like(iter.alpha = alpha, iter.sigma = sigma)
  k = 0
  alpha_old <- alpha; sigma_old <- sigma
  output <- c(k, alpha_old, sigma_old, ll_old)
  diff <- tol + 1

  #t <- try((diff > tol) & (k < maxiter))

  #while(k != "try-error" & t == TRUE){
  while( (diff > tol) & (k < maxiter)){
    #### M step
    alpha <- suppressWarnings(stats::nlm(function(x) length(data)*(log(x)/x + lgamma(1/x)) - sum(c_old - a_old, na.rm = TRUE)/x , p = alpha)$estimate)
    sigma <- sqrt(2)*mean(b_old*abs(data), na.rm = TRUE)
    expect <- all.expectations(iter.alpha = alpha, iter.sigma = sigma)
    a_old <- expect$a_k; b_old <- expect$b_k; c_old <- expect$c_k
    ll_new <- log_like(iter.alpha = alpha, iter.sigma = sigma)
    diff <- ll_new - ll_old
    ll_old <- ll_new
    k <- k + 1
    t <- try((diff > tol) & (k < maxiter))
    output <- rbind(output, c(k, alpha, sigma, ll_new))
    if(verb){
      cat("iteration =", k, " log.lik.diff =", diff, " log.lik =",
          ll_new, "\n")}

    if(k == maxiter){
      cat("Warning! Convergence not achieved!", "\n")
    }
    output <- data.frame(output)
    colnames(output) <- c("iteration","alpha", "sigma","log-lik")
    par <- data.frame(t(c(alpha, sigma)))
    colnames(par) <- c("alpha", "sigma")
    result <- list(par=par, log.like = ll_new, iterations=k, output=output)
  }
  return(result)
}

#### Real Data Fit
SGD <- read.csv('SGD.csv')
SGD.return <- as.numeric(SGD$Close)
SGD.return <- SGD.return[!is.na(SGD.return)]
SGD.return <- diff(log(SGD.return))
SGD.return <- SGD.return[which(SGD.return!= 0) ]
hist(SGD.return, freq = FALSE, breaks = 50, main = "", xlab = "USD/SGD return")

MME.case3.alpha.sigma(data = SGD.return)
EM.case.3.alpha.sigma(data = SGD.return, sigma = 0.5, alpha = 0.5)

#----------------------------------------------------------
########### Pareto-normal (asymmetric cases) ###############
#-----------------------------------------------------------
library(cubature); library(rootSolve)
####---- The PDF -------#####
ANP.pdf <- function(y, alpha = 0.5, sigma = 1, mu = 1){
 bb <- array(NA, dim = length(y))
  for(i in y){
    pos <- match(i, y)
    if(i >= 0){
    gg <- function(t){
      yy <- t*exp(-2*abs(i)*t/(sqrt(2*sigma^2*t + mu^2) + mu))/sqrt(2*sigma^2*t + mu^2)
      uu <- yy*(t^(1/alpha - 1)*exp(-t/alpha))/(alpha^(1/alpha)*gamma(1/alpha))
      return(uu)
    }
    #bb[pos] <- integrate(gg, lower = 0, upper = Inf)$value
    bb[pos] <- adaptIntegrate(gg, lowerLimit = 0, upperLimit = Inf)$integral
    }
  else{
    gg <- function(t){
      yy <- t*exp(-2*abs(i)*t/(sqrt(2*sigma^2*t + mu^2) - mu))/sqrt(2*sigma^2*t + mu^2)
      uu <- yy*(t^(1/alpha - 1)*exp(-t/alpha))/(alpha^(1/alpha)*gamma(1/alpha))
      return(uu)
    }
    bb[pos] <- integrate(gg, lower = 0, upper = Inf)$value
  }
  }
return(bb)
}

###----- Curve for PDF -----#####
graph.f.x.ANP <- function(alpha.par = 0.5, sigma.par = 1, mu.par = 1, start = -10, end = 10){
  ANP.pdf <- function(y, alpha = alpha.par, sigma = sigma.par, mu = mu.par){
    bb <- array(NA, dim = length(y))
    for(i in y){
      pos <- match(i, y)
      if(i >= 0){
        gg <- function(t){
          yy <- t*exp(-2*abs(i)*t/(sqrt(2*sigma^2*t + mu^2) + mu))/sqrt(2*sigma^2*t + mu^2)
          uu <- yy*(t^(1/alpha - 1)*exp(-t/alpha))/(alpha^(1/alpha)*gamma(1/alpha))
          return(uu)
        }

        bb[pos] <- integrate(gg, lower = 0, upper = Inf)$value
      }
      else{
        gg <- function(t){
          yy <- t*exp(-2*abs(i)*t/(sqrt(2*sigma^2*t + mu^2) - mu))/sqrt(2*sigma^2*t + mu^2)
          uu <- yy*(t^(1/alpha - 1)*exp(-t/alpha))/(alpha^(1/alpha)*gamma(1/alpha))
          return(uu)
        }

        bb[pos] <- integrate(gg, lower = 0, upper = Inf)$value
      }

    }
    return(bb)
  }
  curve(ANP.pdf, from = start, to = end, ylab = "f(y)", xlab = "y", col = "blue")
  legend(x = 3, y = 0.3, legend = paste(c("alpha =", alpha.par, "; sigma =", sigma.par, "; mu =", mu.par),
                                        collapse = " "), lty = 1, col =c("blue"), cex = 0.7, box.col = "white", text.width = 3)
}

graph.f.x.ANP(alpha.par = 0.5, sigma.par = 1)

### PDF plots
val <- seq(-10, 10, by = 0.01)
f.1 <- ANP.pdf(y = val, alpha = 0.7, sigma = 1, mu = 1)
f.2 <- ANP.pdf(y = val, alpha = 2, sigma = 1, mu = 1)
f.3 <- ANP.pdf(y = val, alpha = 5, sigma = 1, mu = 1)

plot(val, f.1, type = "l", col = "black", xlab = "y", ylab = "Density", ylim = c(0, max(f.1, f.2, f.3)))
points(val, f.2, type = "l", lty = "dotted", col = "red")
points(val, f.3, type = "l", lty = "twodash", col = "blue")
legend(x = -9, y = 0.3, legend = c(expression(paste(mu, " = 1; ", alpha, " = 0.7; ", sigma, " = 1")), expression(paste(mu, " = 1; ", alpha, " = 2; ", sigma, " = 1")), expression(paste(mu, " = 1; ", alpha, " = 5; ", sigma, " = 1"))),
       lty = c(1, 3, 5), col = c("black", "red", "blue"), cex = 1.2, text.width = 2.5, bty = "n")

g.1 <- ANP.pdf(y = val, alpha = 1.5, sigma = 1, mu = -1)
g.2 <- ANP.pdf(y = val, alpha = 1.5, sigma = 1, mu = 0)
g.3 <- ANP.pdf(y = val, alpha = 1.5, sigma = 1, mu = 2)

par(mfrow = c(1, 3))
plot(val, g.1, type = "l", xlab = "y", ylab = "Density")
legend(x = -2, y = 0.3, legend = c(expression(paste(mu, " = -1; ", alpha, " = 1.5; ", sigma, " = 1"))),
       cex = 1.2, text.width = 2.5, bty = "n")

plot(val, g.2, type = "l", xlab = "y", ylab = "Density")
legend(x = 0, y = 0.3, legend = c(expression(paste(mu, " = 0; ", alpha, " = 1.5; ", sigma, " = 1"))),
       cex = 1.2, text.width = 2.5, bty = "n")

plot(val, g.3, type = "l", xlab = "y", ylab = "Density")
legend(x = 0, y = 0.2, legend = c(expression(paste(mu, " = 2; ", alpha, " = 1.5; ", sigma, " = 1"))),
       cex = 1.2, text.width = 2.5, bty = "n")

###---- The CDF ------#####
ANP.cdf <- function(y, alpha = 1, sigma = 1, mu = 1){
 bb <- array(NA, dim = length(y))
  for(i in y){
   pos <- match(i, y)
#    gg <- function(t){(0.5*exp(-sqrt(2*t)*abs(i)/sigma)*t^((1/alpha) - 1)*exp(-t/alpha))/(alpha^(1/alpha)*gamma(1/alpha))}
  gg <- function(t){0.5*((1 + (mu/(sqrt(2*(sigma^2)*t + mu^2))))*exp(-2*t*abs(i)/( sqrt(2*(sigma^2)*t + mu^2 ) + mu))*(t^(1/alpha - 1)*exp(-t/alpha)/(alpha^(1/alpha)*gamma(1/alpha))))}
  gg.1 <- function(t){0.5*((1 - (mu/(sqrt(2*(sigma^2)*t + mu^2))))*exp(-2*t*abs(i)/( sqrt(2*(sigma^2)*t + mu^2 ) - mu))*(t^(1/alpha - 1)*exp(-t/alpha)/(alpha^(1/alpha)*gamma(1/alpha))))}

  if(i < 0){
      #bb[pos] <- integrate(gg.1, lower = 0, upper = Inf)$value
    bb[pos] <- adaptIntegrate(gg.1, lowerLimit = 0, upperLimit = Inf)$integral
      }
    else if(i >= 0){
    #  bb[pos] <- 1 - integrate(gg, lower = 0, upper = Inf)$value
      bb[pos] <- 1 - adaptIntegrate(gg, lowerLimit = 0, upperLimit = Inf)$integral
      }
    }
 return(bb)
}

####----- Curve for CDF -----####
curve(ANP.cdf, from = -30, to = 30, ylab = "F(y)", xlab = "y")

### Other CDFs with different parameter combinations
val <- seq(-30, 30, by = 0.01)
f.1 <- ANP.cdf(y = val, alpha = 0.7, sigma = 1, mu = 1)
f.2 <- ANP.cdf(y = val, alpha = 1, sigma = 1, mu = 1)
f.3 <- ANP.cdf(y = val, alpha = 2, sigma = 1, mu = 1)

plot(val, f.1, type = "l", col = "black", xlab = "y", ylab = "CDF", ylim = c(0, max(f.1, f.2, f.3)))
points(val, f.2, type = "l", lty = "dotted", col = "red")
points(val, f.3, type = "l", lty = "twodash", col = "blue")
legend(x = -35, y = 0.4, legend = c(expression(paste(mu, " = 1; ", alpha, " = 0.7; ", sigma, " = 1")), expression(paste(mu, " = 1; ", alpha, " = 1; ", sigma, " = 1")), expression(paste(mu, " = 1; ", alpha, " = 2; ", sigma, " = 1"))),
       lty = c(1, 3, 5), col = c("black", "red", "blue"), cex = 1.2, text.width = 1, bty = "n", seg.len = 0.5)

val <- seq(-30, 30, by = 0.01)
g.1 <- ANP.cdf(y = val, alpha = 1, sigma = 1, mu = -1)
g.2 <- ANP.cdf(y = val, alpha = 1, sigma = 1, mu = 0)
g.3 <- ANP.cdf(y = val, alpha = 1, sigma = 1, mu = 2)

plot(val, g.1, type = "l", col = "black", xlab = "y", ylab = "CDF", ylim = c(0, max(g.1, g.2, g.3)))
points(val, g.2, type = "l", lty = "dotted", col = "red")
points(val, g.3, type = "l", lty = "twodash", col = "blue")
legend(x = -35, y = 0.6, legend = c(expression(paste(mu, " = -1; ", alpha, " = 1; ", sigma, " = 1")), expression(paste(mu, " = 0; ", alpha, " = 1; ", sigma, " = 1")), expression(paste(mu, " = 2; ", alpha, " = 1; ", sigma, " = 1"))),
       lty = c(1, 3, 5), col = c("black", "red", "blue"), cex = 1.2, text.width = 1, bty = "n", seg.len = 0.5)

#plot(val, f.1, type = "l", col = "black", xlab = "y", ylab = "F(y)", ylim = c(min(f.1,f.2,f.3), 1))
#points(val, f.2, type = "l", lty = "dotted", col = "red")
#points(val, f.3, type = "l", lty = "twodash", col = "blue")
#legend("bottomright", legend = c("alpha = 0.6, sigma = 1, mu = -1.2", "alpha = 0.6, sigma = 1, mu = 0",
#                                    "alpha = 0.6, sigma = 1, mu = 3"), lty = c(1, 3, 5), col = c("black", "red", "blue"), cex = 0.7, text.width = 8)
#legend(x = 0.5, y = 0.4, legend = c("alpha = 0.6, sigma = 3", "alpha = 1, sigma = 1",
#                                    "alpha = 2, sigma = 1.5"), lty = c(1, 3, 5), col = c("black", "red", "blue"), cex = 0.7, text.width = 8)

# Obtain n random samples from NP
rANPare <- function(n = 1, alpha = 0.5, sigma = 1, mu = 1){
    normal <- rnorm(n); exponential <- rexp(n)
    gamm <- rgamma(n, shape = 1/alpha, scale = alpha)
    y <- mu*(exponential/gamm) + sigma*sqrt(exponential/gamm)*normal
    return(y)
}

# Graph overlay of numbers generated versus the density
par(mfrow = c(2, 2))

alpha.par <- 0.5; sigma.par <- 1; mu.par = 1
X <- rANPare(n = 1000, alpha = alpha.par, sigma = sigma.par, mu = mu.par)
jj <- ANP.pdf(y = seq(min(X), max(X), by = 0.001), alpha = alpha.par, sigma = sigma.par, mu = mu.par)
hist(X, freq = FALSE, ylim = c(0, max(jj)), main = "", col = "gray", xlab = "y", breaks = 80)
points(x = seq(min(X), max(X), by = 0.001), y = jj, type = "l", col = "red")
legend(x = 7, y = 0.3, legend = c(expression(paste(alpha, " = 0.5; ", sigma, " = 1; ",mu, " = 1" ))), bty = "n", cex = 1.2, text.width = 6.5)

#legend(x = 9, y = 0.3, legend = paste(c("alpha =", alpha.par, ";", "sigma =", sigma.par,";","mu =", mu.par), collapse = " "),box.col = "white", cex = 0.8, text.width = 6.5)
#alpha.par <- 0.7; sigma.par <- 1; mu.par = -1
#X <- rANPare(n = 1000, alpha = alpha.par, sigma = sigma.par, mu = mu.par)
#jj <- ANP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par, mu = mu.par)
#hist(X, freq = FALSE, ylim = c(0, max(jj)), main = "", col = "gray", xlab = "y", breaks = 80)
#points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
#legend(x = "center", legend = paste(c("alpha =", alpha.par, ";", "sigma =", sigma.par,";","mu =", mu.par), collapse = " "),box.col = "white", cex = 0.8, text.width = 6.5)
#legend(x = "top", legend = paste(c("alpha =", alpha.par, ";", "sigma =", sigma.par), collapse = " "),box.col = "white", cex = 0.8, text.width = 6.5)

alpha.par <- 0.5; sigma.par <- 1; mu.par = - 1
X <- rANPare(n = 1000, alpha = alpha.par, sigma = sigma.par, mu =  mu.par)
jj <- ANP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par, mu = mu.par)
hist(X, freq = FALSE, ylim = c(0, max(jj)), main = "", col = "gray", xlab = "y", breaks = 80)
points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
legend(x = -60, y = 0.3, legend = c(expression(paste(alpha, " = 0.5; ", sigma, " = 1; ",mu, " = - 1" ))), bty = "n", cex = 1.2, text.width = 6.5)
#legend(x = "topleft", legend = paste(c("alpha =", alpha.par, ";", "sigma =", sigma.par,"; mu =", mu.par), collapse = " "),box.col = "white", cex = 0.8, text.width = 6.5)

alpha.par <- 0.5; sigma.par <- 1; mu.par = 0
X <- rANPare(n = 1000, alpha = alpha.par, sigma = sigma.par, mu =  mu.par)
jj <- ANP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par, mu = mu.par)
hist(X, freq = FALSE, ylim = c(0, max(jj)), main = "", col = "gray", xlab = "y", breaks = 80)
points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
legend(x = -2, y = 0.4, legend = c(expression(paste(alpha, " = 0.5; ", sigma, " = 1; ",mu, " = 0" ))), bty = "n", cex = 1.2, text.width = 6.5)

#alpha.par <- 0.1; sigma.par <- 10; mu.par = 5
#X <- rANPare(n = 1000, alpha = alpha.par, sigma = sigma.par, mu = mu.par)
#jj <- ANP.pdf(y = seq(min(X), max(X), by = 0.01), alpha = alpha.par, sigma = sigma.par, mu = mu.par)
#hist(X, freq = FALSE, ylim = c(0, max(jj)+0.02), main = "", col = "gray", xlab = "y", breaks = 45)
#points(x = seq(min(X), max(X), by = 0.01), y = jj, type = "l", col = "red")
#legend(x = "top", legend = paste(c("alpha =", alpha.par, ";", "sigma =", sigma.par, "; mu =", mu.par), collapse = " "),box.col = "white", cex = 0.8, text.width = 6.5)

par(mfrow = c(1, 1))

#####------------ Quantile Function -----------------######
AY.quantile <- function(alpha = 0.5, sigma = 1, mu = 1, u = 0.1){
  require(rootSolve)
  xxx <- ANP.cdf(alpha = alpha, sigma = sigma, mu = mu, y = 0)
  ans.roots <- array(NA, dim = length(u))

  for(i in u){
  pos <- match(i, u)
  #i = 0.4177055
 func <- function(x, t){
  #h <- function(t) ((beta.par^r.par)/gamma(r.par))*pgamma(t, x)*t^(r.par - 1)*exp(- beta.par*t)
  h1 <- function(t)(0.5*((1 + mu/sqrt(2*sigma^2*t + mu^2))*exp(-2*t*abs(x)/(sqrt(2*sigma^2*t + mu^2) + mu))*(t^(1/alpha - 1)*exp(-t/alpha)/(alpha^(1/alpha)*gamma(1/alpha)))))
  f <-  1 - integrate(h1, lower = 0, upper = Inf)$value - i
  return(f)
  }

 func2 <- function(x, t){
   #h <- function(t) ((beta.par^r.par)/gamma(r.par))*pgamma(t, x)*t^(r.par - 1)*exp(- beta.par*t)
   h2 <- function(t)(0.5*((1 - mu/sqrt(2*sigma^2*t + mu^2))*exp(-2*t*abs(x)/(sqrt(2*sigma^2*t + mu^2) - mu))*(t^(1/alpha - 1)*exp(-t/alpha)/(alpha^(1/alpha)*gamma(1/alpha)))))
   f <-  integrate(h2, lower = 0, upper = Inf)$value - i
   return(f)
 }

 if(i == xxx){
   ans.roots[pos] <- 0
 }
 else if(i < xxx){
   ans.roots[pos] <- uniroot(func2, lower = -100, upper = -0.0002, extendInt = "yes")$root
 }
 else{
   ans.roots[pos] <- uniroot(func, lower =  0.0002, upper = 100, extendInt = "yes")$root
 }
  }
 return(ans.roots)
}

#emp.cdf <- function(data, cor = 0.25){
#  s <- sort(data); n <- length(data)
#  uni <- unique(sort(data))
#  cdf <- array(NA, dim = length(uni))
#  for(i in uni){
#    pos <- match(i, uni)
#    cdf[pos] <- length(which(s <= i))/n
#  }
#  mon <- n/(n + cor)  # using correction for final (tail) value
#  cdf[length(uni)] <- mon
#  uni[length(uni)] <- quantile(s, probs = mon)
#  return(data.frame(X = uni, Empirical_CDF = cdf))
#}

emp.cdf <- function(data, cor = 0.25){
  s <- sort(data); n <- length(data)
  uni <- unique(sort(data))
  cdf <- array(NA, dim = length(uni))
  for(i in uni){
    pos <- match(i, uni)
    cdf[pos] <- length(which(s <= i))/(n + cor )
  }
  return(data.frame(X = uni, Empirical_CDF = cdf))
}

QQ.plot.Ay <- function(data, alpha.est, sigma.est, mu.est, corr = 0.25){
  jj <- emp.cdf(data, cor = corr)
  mm <- array(NA, dim = length(jj$X))
  for(i in jj$Empirical_CDF){
    pos <- match(i, jj$Empirical_CDF)
    mm[pos] <- AY.quantile(i, alpha = alpha.est, sigma = sigma.est, mu = mu.est)
  }
  #plot(mm, jj$X, xlab = "Theoretical Quantiles", ylab = "Sample Quantiles",
   #    main = "Asymmetric Normal-Pareto Q-Q Plot")
  plot(mm, jj$X, xlab = "Theoretical Quantiles", ylab = "Sample Quantiles")
  abline(a = 0, b = 1, col = "red")
}

# Example showing QQ plot works
jj <- rANPare(n = 1000, alpha = 0.5, sigma = 1, mu = 2)
QQ.plot.Ay(data = jj, alpha.est = 0.5, sigma.est = 1, mu.est = 2)
